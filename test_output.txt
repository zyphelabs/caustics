   Compiling caustics v0.1.0 (/home/adriano/Sviluppo/caustics/caustics)
Parse error: expected `,`
error: Failed to parse generated items: expected `,`
 --> caustics/tests/blog_test.rs:5:1
  |
5 | #[caustics(namespace = "blog")]
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

Parse error: expected `,`
error: Failed to parse generated items: expected `,`
  --> caustics/tests/blog_test.rs:45:1
   |
45 | #[caustics(namespace = "blog")]
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

Parse error: expected `,`
Parse error: expected `,`
error: Failed to parse generated items: expected `,`
 --> caustics/tests/school_test.rs:5:1
  |
5 | #[caustics(namespace = "school")]
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

Parse error: expected `,`
Parse error: expected `,`
error: Failed to parse generated items: expected `,`
  --> caustics/tests/school_test.rs:64:1
   |
64 | #[caustics(namespace = "school")]
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

Parse error: expected `,`
error: Failed to parse generated items: expected `,`
   --> caustics/tests/school_test.rs:126:1
    |
126 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0432]: unresolved imports `super::post`, `super::user`
   --> caustics/tests/blog_test.rs:100:17
    |
100 |     use super::{post, user};
    |                 ^^^^  ^^^^ no `user` in the root
    |                 |
    |                 no `post` in the root

Parse error: expected `,`
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:3145
  |
1 | ...ityClient < '_ , DatabaseConnection > { user :: EntityClient :: new (& * self . db) } pub fn post (& self) -> post :: EntityClient < '...
  |                                            ^^^^ use of unresolved module or unlinked crate `user`
  |
  = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

Parse error: expected `,`
error: Failed to parse generated items: expected `,`
   --> caustics/tests/school_test.rs:177:1
    |
177 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

Parse error: expected `,`
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:3266
  |
1 | ...ityClient < '_ , DatabaseConnection > { post :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (t...
  |                                            ^^^^ use of unresolved module or unlinked crate `post`
  |
  = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

Parse error: expected `,`
error: Failed to parse generated items: expected `,`
   --> caustics/tests/school_test.rs:279:1
    |
279 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:3508
  |
1 | ...tyClient < '_ , DatabaseTransaction > { user :: EntityClient :: new (& * self . tx) } pub fn post (& self) -> post :: EntityClient < '...
  |                                            ^^^^ use of unresolved module or unlinked crate `user`
  |
  = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

Parse error: expected `,`
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:3630
  |
1 | ...tyClient < '_ , DatabaseTransaction > { post :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F...
  |                                            ^^^^ use of unresolved module or unlinked crate `post`
  |
  = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:161:26
    |
161 |             .find_unique(user::id::equals(1))
    |                          ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:170:30
    |
170 |             .find_first(vec![user::name::equals("John"), user::age::gt(18)])
    |                              ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

Parse error: expected `,`
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:170:58
    |
170 |             .find_first(vec![user::name::equals("John"), user::age::gt(18)])
    |                                                          ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:179:29
    |
179 |             .find_many(vec![user::age::gt(18)])
    |                             ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:200:22
    |
200 |                 vec![user::age::set(Some(25)), user::deleted_at::set(None)],
    |                      ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:200:48
    |
200 |                 vec![user::age::set(Some(25)), user::deleted_at::set(None)],
    |                                                ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

Parse error: expected `,`
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:208:30
    |
208 |             .find_first(vec![user::email::equals(&email)])
    |                              ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:224:17
    |
224 |                 user::id::equals(user.id),
    |                 ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:225:22
    |
225 |                 vec![post::content::set(Some(
    |                      ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:235:30
    |
235 |             .find_first(vec![post::id::equals(post.id)])
    |                              ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:262:22
    |
262 |                 vec![user::age::set(Some(25)), user::deleted_at::set(None)],
    |                      ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:262:48
    |
262 |                 vec![user::age::set(Some(25)), user::deleted_at::set(None)],
    |                                                ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:272:17
    |
272 |                 user::id::equals(user.id),
    |                 ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:273:22
    |
273 |                 vec![user::name::set("John Doe"), user::age::set(Some(26))],
    |                      ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:273:51
    |
273 |                 vec![user::name::set("John Doe"), user::age::set(Some(26))],
    |                                                   ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:296:26
    |
296 |                     vec![user::age::set(Some(20 + i)), user::deleted_at::set(None)],
    |                          ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

Parse error: expected `,`
error: Failed to parse generated items: expected `,`
   --> caustics/tests/school_test.rs:415:1
    |
415 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:296:56
    |
296 |                     vec![user::age::set(Some(20 + i)), user::deleted_at::set(None)],
    |                                                        ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:309:23
    |
309 |             .order_by(user::age::order(SortOrder::Desc))
    |                       ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:333:22
    |
333 |                 vec![user::age::set(Some(25)), user::deleted_at::set(None)],
    |                      ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:333:48
    |
333 |                 vec![user::age::set(Some(25)), user::deleted_at::set(None)],
    |                                                ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:342:21
    |
342 |             .delete(user::id::equals(user.id))
    |                     ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:350:26
    |
350 |             .find_unique(user::id::equals(user.id))
    |                          ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:366:17
    |
366 |                 user::email::equals("john@example.com"),
    |                 ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:374:22
    |
374 |                 vec![user::name::set("John"), user::age::set(25)],
    |                      ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

Parse error: expected `,`
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:374:47
    |
374 |                 vec![user::name::set("John"), user::age::set(25)],
    |                                               ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:386:17
    |
386 |                 user::email::equals("john@example.com"),
    |                 ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:394:22
    |
394 |                 vec![user::name::set("John Doe"), user::age::set(26)],
    |                      ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:394:51
    |
394 |                 vec![user::name::set("John Doe"), user::age::set(26)],
    |                                                   ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:434:29
    |
434 | ...                   user::id::equals(user.id),
    |                       ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:435:34
    |
435 | ...                   vec![post::content::set("This is my first post".to_string())],
    |                            ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:452:30
    |
452 |             .find_first(vec![user::email::equals(&email_for_check)])
    |                              ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:495:30
    |
495 |             .find_first(vec![user::email::equals(&email_for_check)])
    |                              ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0432]: unresolved imports `super::student`, `super::teacher`, `super::department`, `super::course`, `super::enrollment`, `super::semester`
   --> caustics/tests/school_test.rs:460:17
    |
460 |     use super::{student, teacher, department, course, enrollment, grade, semester};
    |                 ^^^^^^^  ^^^^^^^  ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^         ^^^^^^^^ no `semester` in the root
    |                 |        |        |           |       |
    |                 |        |        |           |       no `enrollment` in the root
    |                 |        |        |           no `course` in the root
    |                 |        |        no `department` in the root
    |                 |        no `teacher` in the root
    |                 no `student` in the root
    |
    = help: consider importing this module instead:
            crate::grade::student
    = help: consider importing this module instead:
            crate::grade::teacher
    = help: consider importing this module instead:
            crate::grade::course

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:542:17
    |
542 |                 user::email::equals(author.email),
    |                 ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:544:21
    |
544 |                     post::content::set("This post has been reviewed".to_string()),
    |                     ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:545:21
    |
545 |                     post::reviewer::connect(user::id::equals(reviewer.id)),
    |                     ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:545:45
    |
545 |                     post::reviewer::connect(user::id::equals(reviewer.id)),
    |                                             ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:558:17
    |
558 |                 user::id::equals(author.id),
    |                 ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:560:21
    |
560 |                     post::content::set("This post hasn't been reviewed yet".to_string()),
    |                     ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:570:26
    |
570 |             .find_unique(user::id::equals(author.id))
    |                          ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0432]: unresolved imports `super::post`, `super::user`
   --> caustics/tests/blog_test.rs:100:17
    |
100 |     use super::{post, user};
    |                 ^^^^  ^^^^ no `user` in `blog_test`
    |                 |
    |                 no `post` in `blog_test`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:571:19
    |
571 |             .with(user::posts::fetch(vec![]))
    |                   ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:584:26
    |
584 |             .find_unique(post::id::equals(post_with_reviewer.id))
    |                          ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0432]: unresolved imports `super::student`, `super::teacher`, `super::department`, `super::course`, `super::enrollment`, `super::semester`
   --> caustics/tests/school_test.rs:460:17
    |
460 |     use super::{student, teacher, department, course, enrollment, grade, semester};
    |                 ^^^^^^^  ^^^^^^^  ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^         ^^^^^^^^ no `semester` in `school_test`
    |                 |        |        |           |       |
    |                 |        |        |           |       no `enrollment` in `school_test`
    |                 |        |        |           no `course` in `school_test`
    |                 |        |        no `department` in `school_test`
    |                 |        no `teacher` in `school_test`
    |                 no `student` in `school_test`
    |
    = help: consider importing this module instead:
            crate::school_test::grade::student
    = help: consider importing this module instead:
            crate::school_test::grade::teacher
    = help: consider importing this module instead:
            crate::school_test::grade::course

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:585:19
    |
585 |             .with(post::reviewer::fetch())
    |                   ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:597:26
    |
597 |             .find_unique(post::id::equals(post_without_reviewer.id))
    |                          ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:598:19
    |
598 |             .with(post::reviewer::fetch())
    |                   ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:620:26
    |
620 |                     vec![user::age::set(Some(25)), user::deleted_at::set(None)],
    |                          ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:620:52
    |
620 |                     vec![user::age::set(Some(25)), user::deleted_at::set(None)],
    |                                                    ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:627:26
    |
627 |                     vec![user::age::set(Some(30))],
    |                          ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `student` in the crate root
   --> caustics/tests/school_test.rs:366:54
    |
366 |     #[derive(Caustics, Copy, Clone, Debug, EnumIter, DeriveRelation)]
    |                                                      ^^^^^^^^^^^^^^ could not find `student` in the crate root
    |
    = note: this error originates in the derive macro `DeriveRelation` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: could not find `course` in the crate root
   --> caustics/tests/school_test.rs:366:54
    |
366 |     #[derive(Caustics, Copy, Clone, Debug, EnumIter, DeriveRelation)]
    |                                                      ^^^^^^^^^^^^^^ could not find `course` in the crate root
    |
    = note: this error originates in the derive macro `DeriveRelation` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: could not find `teacher` in the crate root
   --> caustics/tests/school_test.rs:366:54
    |
366 |     #[derive(Caustics, Copy, Clone, Debug, EnumIter, DeriveRelation)]
    |                                                      ^^^^^^^^^^^^^^ could not find `teacher` in the crate root
    |
    = note: this error originates in the derive macro `DeriveRelation` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: could not find `student` in the crate root
   --> caustics/tests/school_test.rs:396:25
    |
396 |     impl Related<super::student::Entity> for Entity {
    |                         ^^^^^^^ could not find `student` in the crate root

error[E0433]: failed to resolve: could not find `course` in the crate root
   --> caustics/tests/school_test.rs:402:25
    |
402 |     impl Related<super::course::Entity> for Entity {
    |                         ^^^^^^ could not find `course` in the crate root

error[E0433]: failed to resolve: could not find `teacher` in the crate root
   --> caustics/tests/school_test.rs:408:25
    |
408 |     impl Related<super::teacher::Entity> for Entity {
    |                         ^^^^^^^ could not find `teacher` in the crate root

error[E0433]: failed to resolve: could not find `student` in the crate root
   --> caustics/tests/school_test.rs:337:1
    |
337 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `student` in the crate root
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:663
  |
1 | ...{ match entity_name { "user" => Some (& user :: EntityFetcherImpl) , "post" => Some (& post :: EntityFetcherImpl) , _ => None , } } } ...
  |                                            ^^^^ use of unresolved module or unlinked crate `user`
  |
  = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:710
  |
1 | ... EntityFetcherImpl) , "post" => Some (& post :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityR...
  |                                            ^^^^ use of unresolved module or unlinked crate `post`
  |
  = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `course` in the crate root
   --> caustics/tests/school_test.rs:337:1
    |
337 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `course` in the crate root
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: could not find `teacher` in the crate root
   --> caustics/tests/school_test.rs:337:1
    |
337 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `teacher` in the crate root
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:387:17
    |
387 |                 user::Create {
    |                 ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:367:17
    |
367 |                 user::Create {
    |                 ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:3094
  |
1 | ...ts (results)) } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseConnection > { user :: EntityClient :: new (& * self . db)...
  |                                            ^^^^ use of unresolved module or unlinked crate `user`
  |
  = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:3215
  |
1 | ... * self . db) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseConnection > { post :: EntityClient :: new (& * self . db)...
  |                                            ^^^^ use of unresolved module or unlinked crate `post`
  |
  = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:3456
  |
1 | ...{ Self { tx } } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseTransaction > { user :: EntityClient :: new (& * self . tx...
  |                                            ^^^^ use of unresolved module or unlinked crate `user`
  |
  = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:3578
  |
1 | ... * self . tx) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseTransaction > { post :: EntityClient :: new (& * self . tx...
  |                                            ^^^^ use of unresolved module or unlinked crate `post`
  |
  = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

Some errors have detailed explanations: E0432, E0433.
For more information about an error, try `rustc --explain E0432`.
error: could not compile `caustics` (test "blog_test") due to 62 previous errors
warning: build failed, waiting for other jobs to finish...
error[E0433]: failed to resolve: could not find `student` in `super`
   --> caustics/tests/school_test.rs:366:54
    |
366 |     #[derive(Caustics, Copy, Clone, Debug, EnumIter, DeriveRelation)]
    |                                                      ^^^^^^^^^^^^^^ could not find `student` in `super`
    |
    = note: this error originates in the derive macro `DeriveRelation` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: could not find `course` in `super`
   --> caustics/tests/school_test.rs:366:54
    |
366 |     #[derive(Caustics, Copy, Clone, Debug, EnumIter, DeriveRelation)]
    |                                                      ^^^^^^^^^^^^^^ could not find `course` in `super`
    |
    = note: this error originates in the derive macro `DeriveRelation` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: could not find `teacher` in `super`
   --> caustics/tests/school_test.rs:366:54
    |
366 |     #[derive(Caustics, Copy, Clone, Debug, EnumIter, DeriveRelation)]
    |                                                      ^^^^^^^^^^^^^^ could not find `teacher` in `super`
    |
    = note: this error originates in the derive macro `DeriveRelation` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: could not find `student` in `super`
   --> caustics/tests/school_test.rs:396:25
    |
396 |     impl Related<super::student::Entity> for Entity {
    |                         ^^^^^^^ could not find `student` in `super`

error[E0433]: failed to resolve: could not find `course` in `super`
   --> caustics/tests/school_test.rs:402:25
    |
402 |     impl Related<super::course::Entity> for Entity {
    |                         ^^^^^^ could not find `course` in `super`

error[E0433]: failed to resolve: could not find `teacher` in `super`
   --> caustics/tests/school_test.rs:408:25
    |
408 |     impl Related<super::teacher::Entity> for Entity {
    |                         ^^^^^^^ could not find `teacher` in `super`

error[E0433]: failed to resolve: could not find `student` in `super`
   --> caustics/tests/school_test.rs:337:1
    |
337 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `student` in `super`
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:543:17
    |
543 |                 student::email::set(Some("alice@example.com".to_string())),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `course` in `super`
   --> caustics/tests/school_test.rs:337:1
    |
337 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `course` in `super`
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:544:17
    |
544 |                 student::phone::set(Some("123456789".to_string())),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:545:17
    |
545 |                 student::graduation_date::set(None),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `teacher` in `super`
   --> caustics/tests/school_test.rs:337:1
    |
337 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `teacher` in `super`
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:551:50
    |
551 |         let found = client.student().find_unique(student::student_number::equals("S12345".to_string()))
    |                                                  ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:569:17
    |
569 |                 department::description::set(Some("CS Dept".to_string())),
    |                 ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
   --> caustics/tests/school_test.rs:623:17
    |
623 |                 teacher::phone::set(None),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `teacher`
    |
    = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
   --> caustics/tests/school_test.rs:624:17
    |
624 |                 teacher::termination_date::set(None),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `teacher`
    |
    = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:642:17
    |
642 |                 course::description::set(None),
    |                 ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
642 -                 course::description::set(None),
642 +                 core::description::set(None),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:658:17
    |
658 |                 student::email::set(Some("charlie@school.edu".to_string())),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:659:17
    |
659 |                 student::phone::set(None),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:660:17
    |
660 |                 student::graduation_date::set(None),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
   --> caustics/tests/school_test.rs:674:17
    |
674 |                 enrollment::withdrawal_date::set(None),
    |                 ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
    |
    = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:716:47
    |
716 |         let s3 = client.student().find_unique(student::student_number::equals("S3".to_string()))
    |                                               ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:744:13
    |
744 |             student::student_number::equals("U1".to_string()),
    |             ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:745:13
    |
745 |             student::first_name::set("Updated".to_string()),
    |             ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:772:13
    |
772 |             student::student_number::equals("S01".to_string()),
    |             ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:774:19
    |
774 |         .order_by(student::student_number::asc())
    |                   ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:780:13
    |
780 |             student::student_number::equals("S02".to_string()),
    |             ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:782:19
    |
782 |         .order_by(student::student_number::asc())
    |                   ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:820:19
    |
820 |             .with(course::department::fetch())
    |                   ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
820 -             .with(course::department::fetch())
820 +             .with(core::department::fetch())
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:821:19
    |
821 |             .with(course::enrollments::fetch(vec![]))
    |                   ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
821 -             .with(course::enrollments::fetch(vec![]))
821 +             .with(core::enrollments::fetch(vec![]))
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:833:142
    |
833 | ...true, fixed_now(), fixed_now(), vec![student::email::set(None)]
    |                                         ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:837:85
    |
837 | ...tudent::id::equals(student.id), vec![student::email::set(Some("nullable@school.edu".to_string()))])
    |                                         ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:841:86
    |
841 |         let updated2 = client.student().update(student::id::equals(student.id), vec![student::email::set(None)])
    |                                                                                      ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:890:50
    |
890 |         let found = client.student().find_unique(student::student_number::equals("S300".to_string())).exec().await.unwrap();
    |                                                  ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3436
  |
1 | ...Client < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClie...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `student`
  |
  = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3566
  |
1 | ...Client < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: Enti...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `teacher`
  |
  = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3702
  |
1 | ...ent < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
  |
  = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3833
  |
1 | ...yClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: Enti...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `course`
  |
  = help: if you wanted to use a crate named `course`, use `cargo add course` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3968
  |
1 | ...ent < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient <...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
  |
  = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4227
  |
1 | ...lient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (t...
  |                                        ^^^^^^^^ use of unresolved module or unlinked crate `semester`
  |
  = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4479
  |
1 | ...lient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClie...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `student`
  |
  = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4610
  |
1 | ...lient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: Enti...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `teacher`
  |
  = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4747
  |
1 | ...nt < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
  |
  = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4879
  |
1 | ...Client < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: Enti...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `course`
  |
  = help: if you wanted to use a crate named `course`, use `cargo add course` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:5015
  |
1 | ...nt < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient <...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
  |
  = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:5276
  |
1 | ...ient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F...
  |                                        ^^^^^^^^ use of unresolved module or unlinked crate `semester`
  |
  = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: could not find `student` in the crate root
   --> caustics/tests/school_test.rs:366:54
    |
366 |     #[derive(Caustics, Copy, Clone, Debug, EnumIter, DeriveRelation)]
    |                                                      ^^^^^^^^^^^^^^ could not find `student` in the crate root
    |
    = note: this error originates in the derive macro `DeriveRelation` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing one of these items
    |
339 +     use sea_orm_migration::seaql_migrations::Column;
    |
339 +     use sqlx::Column;
    |

error[E0433]: failed to resolve: could not find `course` in the crate root
   --> caustics/tests/school_test.rs:366:54
    |
366 |     #[derive(Caustics, Copy, Clone, Debug, EnumIter, DeriveRelation)]
    |                                                      ^^^^^^^^^^^^^^ could not find `course` in the crate root
    |
    = note: this error originates in the derive macro `DeriveRelation` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing one of these items
    |
339 +     use sea_orm_migration::seaql_migrations::Column;
    |
339 +     use sqlx::Column;
    |

error[E0433]: failed to resolve: could not find `teacher` in the crate root
   --> caustics/tests/school_test.rs:366:54
    |
366 |     #[derive(Caustics, Copy, Clone, Debug, EnumIter, DeriveRelation)]
    |                                                      ^^^^^^^^^^^^^^ could not find `teacher` in the crate root
    |
    = note: this error originates in the derive macro `DeriveRelation` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing one of these items
    |
339 +     use sea_orm_migration::seaql_migrations::Column;
    |
339 +     use sqlx::Column;
    |

error[E0433]: failed to resolve: could not find `Expr` in `sea_orm`
   --> caustics/tests/school_test.rs:337:1
    |
337 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `Expr` in `sea_orm`
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing one of these structs
    |
339 +     use sea_orm::prelude::Expr;
    |
339 +     use sea_orm_migration::prelude::Expr;
    |
339 +     use sea_query::Expr;
    |

error[E0433]: failed to resolve: could not find `Column` in `sea_orm`
   --> caustics/tests/school_test.rs:337:1
    |
337 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `Column` in `sea_orm`
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing one of these items
    |
339 +     use sea_orm_migration::seaql_migrations::Column;
    |
339 +     use sqlx::Column;
    |

error[E0433]: failed to resolve: could not find `student` in the crate root
   --> caustics/tests/school_test.rs:337:1
    |
337 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `student` in the crate root
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing this struct
    |
339 +     use sea_orm_migration::seaql_migrations::Entity;
    |

error[E0433]: failed to resolve: could not find `course` in the crate root
   --> caustics/tests/school_test.rs:337:1
    |
337 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `course` in the crate root
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing this struct
    |
339 +     use sea_orm_migration::seaql_migrations::Entity;
    |

error[E0433]: failed to resolve: could not find `teacher` in the crate root
   --> caustics/tests/school_test.rs:337:1
    |
337 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `teacher` in the crate root
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing this struct
    |
339 +     use sea_orm_migration::seaql_migrations::Entity;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:546:17
    |
546 |                 student::deleted_at::set(None),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`
help: consider importing this module
    |
518 +     use crate::grade::deleted_at;
    |
help: if you import `deleted_at`, refer to it directly
    |
546 -                 student::deleted_at::set(None),
546 +                 deleted_at::set(None),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:570:17
    |
570 |                 department::deleted_at::set(None),
    |                 ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`
help: consider importing this module
    |
518 +     use crate::grade::deleted_at;
    |
help: if you import `deleted_at`, refer to it directly
    |
570 -                 department::deleted_at::set(None),
570 +                 deleted_at::set(None),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
   --> caustics/tests/school_test.rs:608:18
    |
608 |             vec![semester::deleted_at::set(None)],
    |                  ^^^^^^^^ use of unresolved module or unlinked crate `semester`
    |
    = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`
help: consider importing this module
    |
518 +     use crate::grade::deleted_at;
    |
help: if you import `deleted_at`, refer to it directly
    |
608 -             vec![semester::deleted_at::set(None)],
608 +             vec![deleted_at::set(None)],
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:621:13
    |
621 |             department::id::equals(dept.id),
    |             ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`
help: consider importing this module
    |
518 +     use crate::grade::id;
    |
help: if you import `id`, refer to it directly
    |
621 -             department::id::equals(dept.id),
621 +             id::equals(dept.id),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
   --> caustics/tests/school_test.rs:625:17
    |
625 |                 teacher::deleted_at::set(None),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `teacher`
    |
    = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`
help: consider importing this module
    |
518 +     use crate::grade::deleted_at;
    |
help: if you import `deleted_at`, refer to it directly
    |
625 -                 teacher::deleted_at::set(None),
625 +                 deleted_at::set(None),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
   --> caustics/tests/school_test.rs:638:13
    |
638 |             teacher::id::equals(teacher.id),
    |             ^^^^^^^ use of unresolved module or unlinked crate `teacher`
    |
    = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`
help: consider importing this module
    |
518 +     use crate::grade::id;
    |
help: if you import `id`, refer to it directly
    |
638 -             teacher::id::equals(teacher.id),
638 +             id::equals(teacher.id),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:639:13
    |
639 |             department::id::equals(dept.id),
    |             ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`
help: consider importing this module
    |
518 +     use crate::grade::id;
    |
help: if you import `id`, refer to it directly
    |
639 -             department::id::equals(dept.id),
639 +             id::equals(dept.id),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
   --> caustics/tests/school_test.rs:640:13
    |
640 |             semester::id::equals(semester.id),
    |             ^^^^^^^^ use of unresolved module or unlinked crate `semester`
    |
    = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`
help: consider importing this module
    |
518 +     use crate::grade::id;
    |
help: if you import `id`, refer to it directly
    |
640 -             semester::id::equals(semester.id),
640 +             id::equals(semester.id),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:643:17
    |
643 |                 course::deleted_at::set(None),
    |                 ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
643 -                 course::deleted_at::set(None),
643 +                 core::deleted_at::set(None),
    |
help: consider importing this module
    |
518 +     use crate::grade::deleted_at;
    |
help: if you import `deleted_at`, refer to it directly
    |
643 -                 course::deleted_at::set(None),
643 +                 deleted_at::set(None),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:661:17
    |
661 |                 student::deleted_at::set(None),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`
help: consider importing this module
    |
518 +     use crate::grade::deleted_at;
    |
help: if you import `deleted_at`, refer to it directly
    |
661 -                 student::deleted_at::set(None),
661 +                 deleted_at::set(None),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:671:13
    |
671 |             student::id::equals(student.id),
    |             ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`
help: consider importing this module
    |
518 +     use crate::grade::id;
    |
help: if you import `id`, refer to it directly
    |
671 -             student::id::equals(student.id),
671 +             id::equals(student.id),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:672:13
    |
672 |             course::id::equals(course.id),
    |             ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
672 -             course::id::equals(course.id),
672 +             core::id::equals(course.id),
    |
help: consider importing this module
    |
518 +     use crate::grade::id;
    |
help: if you import `id`, refer to it directly
    |
672 -             course::id::equals(course.id),
672 +             id::equals(course.id),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
   --> caustics/tests/school_test.rs:675:17
    |
675 |                 enrollment::deleted_at::set(None),
    |                 ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
    |
    = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`
help: consider importing this module
    |
518 +     use crate::grade::deleted_at;
    |
help: if you import `deleted_at`, refer to it directly
    |
675 -                 enrollment::deleted_at::set(None),
675 +                 deleted_at::set(None),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
   --> caustics/tests/school_test.rs:680:62
    |
680 |         let enrollments = client.enrollment().find_many(vec![enrollment::student_id::equals(student.id)])
    |                                                              ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
    |
    = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`
help: consider importing this module
    |
518 +     use crate::grade::student_id;
    |
help: if you import `student_id`, refer to it directly
    |
680 -         let enrollments = client.enrollment().find_many(vec![enrollment::student_id::equals(student.id)])
680 +         let enrollments = client.enrollment().find_many(vec![student_id::equals(student.id)])
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:802:149
    |
802 | ..., true, fixed_now(), fixed_now(), department::id::equals(dept.id), vec![]
    |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::grade::id;
    |
help: if you import `id`, refer to it directly
    |
802 -             "T002".to_string(), "Eve".to_string(), "Newton".to_string(), "eve@school.edu".to_string(), fixed_now(), true, fixed_now(), fixed_now(), department::id::equals(dept.id), vec![]
802 +             "T002".to_string(), "Eve".to_string(), "Newton".to_string(), "eve@school.edu".to_string(), fixed_now(), true, fixed_now(), fixed_now(), id::equals(dept.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
   --> caustics/tests/school_test.rs:806:97
    |
806 | ... 40, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.i...
    |                                         ^^^^^^^ use of unresolved module or unlinked crate `teacher`
    |
    = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::grade::id;
    |
help: if you import `id`, refer to it directly
    |
806 -             "SCI101".to_string(), "Physics".to_string(), 5, 40, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
806 +             "SCI101".to_string(), "Physics".to_string(), 5, 40, true, fixed_now(), fixed_now(), id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:806:130
    |
806 | ... teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
    |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::grade::id;
    |
help: if you import `id`, refer to it directly
    |
806 -             "SCI101".to_string(), "Physics".to_string(), 5, 40, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
806 +             "SCI101".to_string(), "Physics".to_string(), 5, 40, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), id::equals(dept.id), semester::id::equals(semester.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
   --> caustics/tests/school_test.rs:806:163
    |
806 | ...), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
    |                                        ^^^^^^^^ use of unresolved module or unlinked crate `semester`
    |
    = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::grade::id;
    |
help: if you import `id`, refer to it directly
    |
806 -             "SCI101".to_string(), "Physics".to_string(), 5, 40, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
806 +             "SCI101".to_string(), "Physics".to_string(), 5, 40, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), department::id::equals(dept.id), id::equals(semester.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:814:76
    |
814 | ...   fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), course::id::equals(course.id), vec![]
    |                                                                      ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::grade::id;
    |
help: if you import `id`, refer to it directly
    |
814 -             fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), course::id::equals(course.id), vec![]
814 +             fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), id::equals(student.id), course::id::equals(course.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:814:109
    |
814 | ...w(), student::id::equals(student.id), course::id::equals(course.id), vec![]
    |                                          ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
814 -             fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), course::id::equals(course.id), vec![]
814 +             fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), core::id::equals(course.id), vec![]
    |
help: consider importing this module
    |
724 +     use crate::grade::id;
    |
help: if you import `id`, refer to it directly
    |
814 -             fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), course::id::equals(course.id), vec![]
814 +             fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), id::equals(course.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:818:59
    |
818 |         let course_with_rel = client.course().find_unique(course::id::equals(course.id))
    |                                                           ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
818 -         let course_with_rel = client.course().find_unique(course::id::equals(course.id))
818 +         let course_with_rel = client.course().find_unique(core::id::equals(course.id))
    |
help: consider importing this module
    |
724 +     use crate::grade::id;
    |
help: if you import `id`, refer to it directly
    |
818 -         let course_with_rel = client.course().find_unique(course::id::equals(course.id))
818 +         let course_with_rel = client.course().find_unique(id::equals(course.id))
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:819:19
    |
819 |             .with(course::teacher::fetch())
    |                   ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
819 -             .with(course::teacher::fetch())
819 +             .with(core::teacher::fetch())
    |
help: consider importing this module
    |
724 +     use crate::grade::teacher;
    |
help: if you import `teacher`, refer to it directly
    |
819 -             .with(course::teacher::fetch())
819 +             .with(teacher::fetch())
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:837:47
    |
837 | ...   let updated = client.student().update(student::id::equals(student.id), vec![student::email::set(Some("nullable@school.edu".to_strin...
    |                                             ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::grade::id;
    |
help: if you import `id`, refer to it directly
    |
837 -         let updated = client.student().update(student::id::equals(student.id), vec![student::email::set(Some("nullable@school.edu".to_string()))])
837 +         let updated = client.student().update(id::equals(student.id), vec![student::email::set(Some("nullable@school.edu".to_string()))])
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:841:48
    |
841 |         let updated2 = client.student().update(student::id::equals(student.id), vec![student::email::set(None)])
    |                                                ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::grade::id;
    |
help: if you import `id`, refer to it directly
    |
841 -         let updated2 = client.student().update(student::id::equals(student.id), vec![student::email::set(None)])
841 +         let updated2 = client.student().update(id::equals(student.id), vec![student::email::set(None)])
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:864:159
    |
864 | ..., true, fixed_now(), fixed_now(), department::id::equals(dept.id), vec![]
    |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::grade::id;
    |
help: if you import `id`, refer to it directly
    |
864 -                 "T003".to_string(), "Frank".to_string(), "Einstein".to_string(), "frank@school.edu".to_string(), fixed_now(), true, fixed_now(), fixed_now(), department::id::equals(dept.id), vec![]
864 +                 "T003".to_string(), "Frank".to_string(), "Einstein".to_string(), "frank@school.edu".to_string(), fixed_now(), true, fixed_now(), fixed_now(), id::equals(dept.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
   --> caustics/tests/school_test.rs:868:101
    |
868 | ... 20, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.i...
    |                                         ^^^^^^^ use of unresolved module or unlinked crate `teacher`
    |
    = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::grade::id;
    |
help: if you import `id`, refer to it directly
    |
868 -                 "TXN101".to_string(), "Quantum".to_string(), 4, 20, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
868 +                 "TXN101".to_string(), "Quantum".to_string(), 4, 20, true, fixed_now(), fixed_now(), id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:868:134
    |
868 | ... teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
    |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::grade::id;
    |
help: if you import `id`, refer to it directly
    |
868 -                 "TXN101".to_string(), "Quantum".to_string(), 4, 20, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
868 +                 "TXN101".to_string(), "Quantum".to_string(), 4, 20, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), id::equals(dept.id), semester::id::equals(semester.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
   --> caustics/tests/school_test.rs:868:167
    |
868 | ...), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
    |                                        ^^^^^^^^ use of unresolved module or unlinked crate `semester`
    |
    = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::grade::id;
    |
help: if you import `id`, refer to it directly
    |
868 -                 "TXN101".to_string(), "Quantum".to_string(), 4, 20, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
868 +                 "TXN101".to_string(), "Quantum".to_string(), 4, 20, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), department::id::equals(dept.id), id::equals(semester.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:872:80
    |
872 | ...   fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), course::id::equals(course.id), vec![]
    |                                                                      ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::grade::id;
    |
help: if you import `id`, refer to it directly
    |
872 -                 fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), course::id::equals(course.id), vec![]
872 +                 fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), id::equals(student.id), course::id::equals(course.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:872:113
    |
872 | ...w(), student::id::equals(student.id), course::id::equals(course.id), vec![]
    |                                          ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
872 -                 fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), course::id::equals(course.id), vec![]
872 +                 fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), core::id::equals(course.id), vec![]
    |
help: consider importing this module
    |
724 +     use crate::grade::id;
    |
help: if you import `id`, refer to it directly
    |
872 -                 fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), course::id::equals(course.id), vec![]
872 +                 fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), id::equals(course.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:880:17
    |
880 |                 student::id::equals(student.id),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::grade::id;
    |
help: if you import `id`, refer to it directly
    |
880 -                 student::id::equals(student.id),
880 +                 id::equals(student.id),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:881:17
    |
881 |                 course::id::equals(course.id),
    |                 ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
881 -                 course::id::equals(course.id),
881 +                 core::id::equals(course.id),
    |
help: consider importing this module
    |
724 +     use crate::grade::id;
    |
help: if you import `id`, refer to it directly
    |
881 -                 course::id::equals(course.id),
881 +                 id::equals(course.id),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
   --> caustics/tests/school_test.rs:882:17
    |
882 |                 teacher::id::equals(teacher.id),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `teacher`
    |
    = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::grade::id;
    |
help: if you import `id`, refer to it directly
    |
882 -                 teacher::id::equals(teacher.id),
882 +                 id::equals(teacher.id),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:666
  |
1 | ...h entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department"...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `student`
  |
  = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:719
  |
1 | ...yFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "cours...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `teacher`
  |
  = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:775
  |
1 | ...erImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" =...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
  |
  = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:830
  |
1 | ...ityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `course`
  |
  = help: if you wanted to use a crate named `course`, use `cargo add course` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:885
  |
1 | ...erImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => So...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
  |
  = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:991
  |
1 | ...etcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityR...
  |                                        ^^^^^^^^ use of unresolved module or unlinked crate `semester`
  |
  = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:3145
  |
1 | ...ityClient < '_ , DatabaseConnection > { user :: EntityClient :: new (& * self . db) } pub fn post (& self) -> post :: EntityClient < '...
  |                                            ^^^^ use of unresolved module or unlinked crate `user`
  |
  = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "user" => Some (& user :: EntityFetcherImpl) , "post" => Some (& post :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseConnection > { user :: EntityClient :: new (& * self . db) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseConnection > { post :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseTransaction > { user :: EntityClient :: new (& * self . tx) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseTransaction > { post :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "user" => Some (& user :: EntityFetcherImpl) , "post" => Some (& post :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseConnection > { post :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseTransaction > { user :: EntityClient :: new (& * self . tx) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseTransaction > { post :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:3266
  |
1 | ...ityClient < '_ , DatabaseConnection > { post :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (t...
  |                                            ^^^^ use of unresolved module or unlinked crate `post`
  |
  = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "user" => Some (& user :: EntityFetcherImpl) , "post" => Some (& post :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseConnection > { user :: EntityClient :: new (& * self . db) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseConnection > { post :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseTransaction > { user :: EntityClient :: new (& * self . tx) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseTransaction > { post :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "user" => Some (& user :: EntityFetcherImpl) , "post" => Some (& post :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseConnection > { user :: EntityClient :: new (& * self . db) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseTransaction > { user :: EntityClient :: new (& * self . tx) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseTransaction > { post :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:3508
  |
1 | ...tyClient < '_ , DatabaseTransaction > { user :: EntityClient :: new (& * self . tx) } pub fn post (& self) -> post :: EntityClient < '...
  |                                            ^^^^ use of unresolved module or unlinked crate `user`
  |
  = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "user" => Some (& user :: EntityFetcherImpl) , "post" => Some (& post :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseConnection > { user :: EntityClient :: new (& * self . db) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseConnection > { post :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseTransaction > { user :: EntityClient :: new (& * self . tx) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseTransaction > { post :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "user" => Some (& user :: EntityFetcherImpl) , "post" => Some (& post :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseConnection > { user :: EntityClient :: new (& * self . db) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseConnection > { post :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseTransaction > { post :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:3630
  |
1 | ...tyClient < '_ , DatabaseTransaction > { post :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F...
  |                                            ^^^^ use of unresolved module or unlinked crate `post`
  |
  = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "user" => Some (& user :: EntityFetcherImpl) , "post" => Some (& post :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseConnection > { user :: EntityClient :: new (& * self . db) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseConnection > { post :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseTransaction > { user :: EntityClient :: new (& * self . tx) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseTransaction > { post :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "user" => Some (& user :: EntityFetcherImpl) , "post" => Some (& post :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseConnection > { user :: EntityClient :: new (& * self . db) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseConnection > { post :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseTransaction > { user :: EntityClient :: new (& * self . tx) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:161:26
    |
161 |             .find_unique(user::id::equals(1))
    |                          ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`
help: consider importing this module
    |
144 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
161 -             .find_unique(user::id::equals(1))
161 +             .find_unique(id::equals(1))
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:200:48
    |
200 |                 vec![user::age::set(Some(25)), user::deleted_at::set(None)],
    |                                                ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`
help: consider importing this module
    |
144 +     use crate::school_test::grade::deleted_at;
    |
help: if you import `deleted_at`, refer to it directly
    |
200 -                 vec![user::age::set(Some(25)), user::deleted_at::set(None)],
200 +                 vec![user::age::set(Some(25)), deleted_at::set(None)],
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:224:17
    |
224 |                 user::id::equals(user.id),
    |                 ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`
help: consider importing this module
    |
144 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
224 -                 user::id::equals(user.id),
224 +                 id::equals(user.id),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:235:30
    |
235 |             .find_first(vec![post::id::equals(post.id)])
    |                              ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`
help: consider importing this module
    |
144 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
235 -             .find_first(vec![post::id::equals(post.id)])
235 +             .find_first(vec![id::equals(post.id)])
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:262:48
    |
262 |                 vec![user::age::set(Some(25)), user::deleted_at::set(None)],
    |                                                ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`
help: consider importing this module
    |
144 +     use crate::school_test::grade::deleted_at;
    |
help: if you import `deleted_at`, refer to it directly
    |
262 -                 vec![user::age::set(Some(25)), user::deleted_at::set(None)],
262 +                 vec![user::age::set(Some(25)), deleted_at::set(None)],
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:272:17
    |
272 |                 user::id::equals(user.id),
    |                 ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`
help: consider importing this module
    |
144 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
272 -                 user::id::equals(user.id),
272 +                 id::equals(user.id),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:296:56
    |
296 |                     vec![user::age::set(Some(20 + i)), user::deleted_at::set(None)],
    |                                                        ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`
help: consider importing this module
    |
144 +     use crate::school_test::grade::deleted_at;
    |
help: if you import `deleted_at`, refer to it directly
    |
296 -                     vec![user::age::set(Some(20 + i)), user::deleted_at::set(None)],
296 +                     vec![user::age::set(Some(20 + i)), deleted_at::set(None)],
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:333:48
    |
333 |                 vec![user::age::set(Some(25)), user::deleted_at::set(None)],
    |                                                ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`
help: consider importing this module
    |
144 +     use crate::school_test::grade::deleted_at;
    |
help: if you import `deleted_at`, refer to it directly
    |
333 -                 vec![user::age::set(Some(25)), user::deleted_at::set(None)],
333 +                 vec![user::age::set(Some(25)), deleted_at::set(None)],
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:342:21
    |
342 |             .delete(user::id::equals(user.id))
    |                     ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`
help: consider importing this module
    |
144 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
342 -             .delete(user::id::equals(user.id))
342 +             .delete(id::equals(user.id))
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:350:26
    |
350 |             .find_unique(user::id::equals(user.id))
    |                          ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`
help: consider importing this module
    |
144 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
350 -             .find_unique(user::id::equals(user.id))
350 +             .find_unique(id::equals(user.id))
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:434:29
    |
434 | ...                   user::id::equals(user.id),
    |                       ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`
help: consider importing this module
    |
144 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
434 -                             user::id::equals(user.id),
434 +                             id::equals(user.id),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:545:45
    |
545 |                     post::reviewer::connect(user::id::equals(reviewer.id)),
    |                                             ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`
help: consider importing this module
    |
144 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
545 -                     post::reviewer::connect(user::id::equals(reviewer.id)),
545 +                     post::reviewer::connect(id::equals(reviewer.id)),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:558:17
    |
558 |                 user::id::equals(author.id),
    |                 ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`
help: consider importing this module
    |
144 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
558 -                 user::id::equals(author.id),
558 +                 id::equals(author.id),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:570:26
    |
570 |             .find_unique(user::id::equals(author.id))
    |                          ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`
help: consider importing this module
    |
144 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
570 -             .find_unique(user::id::equals(author.id))
570 +             .find_unique(id::equals(author.id))
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:584:26
    |
584 |             .find_unique(post::id::equals(post_with_reviewer.id))
    |                          ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`
help: consider importing this module
    |
144 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
584 -             .find_unique(post::id::equals(post_with_reviewer.id))
584 +             .find_unique(id::equals(post_with_reviewer.id))
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:597:26
    |
597 |             .find_unique(post::id::equals(post_without_reviewer.id))
    |                          ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`
help: consider importing this module
    |
144 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
597 -             .find_unique(post::id::equals(post_without_reviewer.id))
597 +             .find_unique(id::equals(post_without_reviewer.id))
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:620:52
    |
620 |                     vec![user::age::set(Some(25)), user::deleted_at::set(None)],
    |                                                    ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`
help: consider importing this module
    |
144 +     use crate::school_test::grade::deleted_at;
    |
help: if you import `deleted_at`, refer to it directly
    |
620 -                     vec![user::age::set(Some(25)), user::deleted_at::set(None)],
620 +                     vec![user::age::set(Some(25)), deleted_at::set(None)],
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3436
  |
1 | ...Client < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClie...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `student`
  |
  = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3566
  |
1 | ...Client < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: Enti...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `teacher`
  |
  = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3702
  |
1 | ...ent < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
  |
  = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3833
  |
1 | ...yClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: Enti...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `course`
  |
  = help: if you wanted to use a crate named `course`, use `cargo add course` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3968
  |
1 | ...ent < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient <...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
  |
  = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4227
  |
1 | ...lient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (t...
  |                                        ^^^^^^^^ use of unresolved module or unlinked crate `semester`
  |
  = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4479
  |
1 | ...lient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClie...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `student`
  |
  = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4610
  |
1 | ...lient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: Enti...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `teacher`
  |
  = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4747
  |
1 | ...nt < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
  |
  = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4879
  |
1 | ...Client < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: Enti...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `course`
  |
  = help: if you wanted to use a crate named `course`, use `cargo add course` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:5015
  |
1 | ...nt < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient <...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
  |
  = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0599]: no variant or associated item named `Contains` found for enum `WhereParam` in the current scope
   --> caustics/tests/school_test.rs:337:1
    |
337 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    | |
    | variant or associated item not found in `WhereParam`
    | variant or associated item `Contains` not found for this enum
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no variant or associated item named `StartsWith` found for enum `WhereParam` in the current scope
   --> caustics/tests/school_test.rs:337:1
    |
337 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    | |
    | variant or associated item not found in `WhereParam`
    | variant or associated item `StartsWith` not found for this enum
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no variant or associated item named `EndsWith` found for enum `WhereParam` in the current scope
   --> caustics/tests/school_test.rs:337:1
    |
337 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    | |
    | variant or associated item not found in `WhereParam`
    | variant or associated item `EndsWith` not found for this enum
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no variant or associated item named `Lt` found for enum `WhereParam` in the current scope
   --> caustics/tests/school_test.rs:337:1
    |
337 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    | |
    | variant or associated item not found in `WhereParam`
    | variant or associated item `Lt` not found for this enum
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no variant or associated item named `Lte` found for enum `WhereParam` in the current scope
   --> caustics/tests/school_test.rs:337:1
    |
337 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    | |
    | variant or associated item not found in `WhereParam`
    | variant or associated item `Lte` not found for this enum
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:5276
  |
1 | ...ient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F...
  |                                        ^^^^^^^^ use of unresolved module or unlinked crate `semester`
  |
  = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } # [doc = r" Execute multiple queries in a single transaction with fail-fast behavior"] pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0599]: no variant or associated item named `Gt` found for enum `WhereParam` in the current scope
   --> caustics/tests/school_test.rs:337:1
    |
337 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    | |
    | variant or associated item not found in `WhereParam`
    | variant or associated item `Gt` not found for this enum
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no variant or associated item named `Gte` found for enum `WhereParam` in the current scope
   --> caustics/tests/school_test.rs:337:1
    |
337 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    | |
    | variant or associated item not found in `WhereParam`
    | variant or associated item `Gte` not found for this enum
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: could not find `student` in `super`
   --> caustics/tests/school_test.rs:366:54
    |
366 |     #[derive(Caustics, Copy, Clone, Debug, EnumIter, DeriveRelation)]
    |                                                      ^^^^^^^^^^^^^^ could not find `student` in `super`
    |
    = note: this error originates in the derive macro `DeriveRelation` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing one of these items
    |
339 +     use sea_orm_migration::seaql_migrations::Column;
    |
339 +     use sqlx::Column;
    |

error[E0599]: no variant or associated item named `Not` found for enum `WhereParam` in the current scope
   --> caustics/tests/school_test.rs:337:1
    |
337 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    | |
    | variant or associated item not found in `WhereParam`
    | variant or associated item `Not` not found for this enum
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: could not find `course` in `super`
   --> caustics/tests/school_test.rs:366:54
    |
366 |     #[derive(Caustics, Copy, Clone, Debug, EnumIter, DeriveRelation)]
    |                                                      ^^^^^^^^^^^^^^ could not find `course` in `super`
    |
    = note: this error originates in the derive macro `DeriveRelation` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing one of these items
    |
339 +     use sea_orm_migration::seaql_migrations::Column;
    |
339 +     use sqlx::Column;
    |

error[E0599]: no variant or associated item named `In` found for enum `WhereParam` in the current scope
   --> caustics/tests/school_test.rs:337:1
    |
337 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    | |
    | variant or associated item not found in `WhereParam`
    | variant or associated item `In` not found for this enum
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)
help: there is a variant with a similar name
    |
337 - #[caustics(namespace = "school")]
337 + Id
    |

error[E0433]: failed to resolve: could not find `teacher` in `super`
   --> caustics/tests/school_test.rs:366:54
    |
366 |     #[derive(Caustics, Copy, Clone, Debug, EnumIter, DeriveRelation)]
    |                                                      ^^^^^^^^^^^^^^ could not find `teacher` in `super`
    |
    = note: this error originates in the derive macro `DeriveRelation` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing one of these items
    |
339 +     use sea_orm_migration::seaql_migrations::Column;
    |
339 +     use sqlx::Column;
    |

error[E0599]: no variant or associated item named `NotIn` found for enum `WhereParam` in the current scope
   --> caustics/tests/school_test.rs:337:1
    |
337 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    | |
    | variant or associated item not found in `WhereParam`
    | variant or associated item `NotIn` not found for this enum
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:5220
  |
1 | .... tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self ...
  |                                        ^^^^^^^^ use of unresolved module or unlinked crate `semester`
  |
  = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4957
  |
1 | ...) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * sel...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
  |
  = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4825
  |
1 | ...elf . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . ...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `course`
  |
  = help: if you wanted to use a crate named `course`, use `cargo add course` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4689
  |
1 | ...) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * sel...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
  |
  = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4555
  |
1 | ...f . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self ....
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `teacher`
  |
  = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4424
  |
1 | ... { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self ....
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `student`
  |
  = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `student` in `super`
   --> caustics/tests/school_test.rs:337:1
    |
337 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `student` in `super`
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing this struct
    |
339 +     use sea_orm_migration::seaql_migrations::Entity;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3382
  |
1 | ...sults)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . ...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `student`
  |
  = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `course` in `super`
   --> caustics/tests/school_test.rs:337:1
    |
337 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `course` in `super`
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing this struct
    |
339 +     use sea_orm_migration::seaql_migrations::Entity;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3512
  |
1 | ...f . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . ...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `teacher`
  |
  = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `teacher` in `super`
   --> caustics/tests/school_test.rs:337:1
    |
337 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `teacher` in `super`
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing this struct
    |
339 +     use sea_orm_migration::seaql_migrations::Entity;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3645
  |
1 | ...) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
  |
  = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3780
  |
1 | ...elf . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . d...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `course`
  |
  = help: if you wanted to use a crate named `course`, use `cargo add course` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3911
  |
1 | ...) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
  |
  = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4172
  |
1 | .... db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self ....
  |                                        ^^^^^^^^ use of unresolved module or unlinked crate `semester`
  |
  = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`

Some errors have detailed explanations: E0432, E0433, E0599.
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:546:17
    |
546 |                 student::deleted_at::set(None),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`
help: consider importing this module
    |
518 +     use crate::school_test::grade::deleted_at;
    |
help: if you import `deleted_at`, refer to it directly
    |
546 -                 student::deleted_at::set(None),
546 +                 deleted_at::set(None),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:570:17
    |
570 |                 department::deleted_at::set(None),
    |                 ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`
help: consider importing this module
    |
518 +     use crate::school_test::grade::deleted_at;
    |
help: if you import `deleted_at`, refer to it directly
    |
570 -                 department::deleted_at::set(None),
570 +                 deleted_at::set(None),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
   --> caustics/tests/school_test.rs:608:18
    |
608 |             vec![semester::deleted_at::set(None)],
    |                  ^^^^^^^^ use of unresolved module or unlinked crate `semester`
    |
    = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`
help: consider importing this module
    |
518 +     use crate::school_test::grade::deleted_at;
    |
help: if you import `deleted_at`, refer to it directly
    |
608 -             vec![semester::deleted_at::set(None)],
608 +             vec![deleted_at::set(None)],
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:621:13
    |
621 |             department::id::equals(dept.id),
    |             ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`
help: consider importing this module
    |
518 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
621 -             department::id::equals(dept.id),
621 +             id::equals(dept.id),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
   --> caustics/tests/school_test.rs:625:17
    |
625 |                 teacher::deleted_at::set(None),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `teacher`
    |
    = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`
help: consider importing this module
    |
518 +     use crate::school_test::grade::deleted_at;
    |
help: if you import `deleted_at`, refer to it directly
    |
625 -                 teacher::deleted_at::set(None),
625 +                 deleted_at::set(None),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
   --> caustics/tests/school_test.rs:638:13
    |
638 |             teacher::id::equals(teacher.id),
    |             ^^^^^^^ use of unresolved module or unlinked crate `teacher`
    |
    = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`
help: consider importing this module
    |
518 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
638 -             teacher::id::equals(teacher.id),
638 +             id::equals(teacher.id),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:639:13
    |
639 |             department::id::equals(dept.id),
    |             ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`
help: consider importing this module
    |
518 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
639 -             department::id::equals(dept.id),
639 +             id::equals(dept.id),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
   --> caustics/tests/school_test.rs:640:13
    |
640 |             semester::id::equals(semester.id),
    |             ^^^^^^^^ use of unresolved module or unlinked crate `semester`
    |
    = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`
help: consider importing this module
    |
518 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
640 -             semester::id::equals(semester.id),
640 +             id::equals(semester.id),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:643:17
    |
643 |                 course::deleted_at::set(None),
    |                 ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
643 -                 course::deleted_at::set(None),
643 +                 core::deleted_at::set(None),
    |
help: consider importing this module
    |
518 +     use crate::school_test::grade::deleted_at;
    |
help: if you import `deleted_at`, refer to it directly
    |
643 -                 course::deleted_at::set(None),
643 +                 deleted_at::set(None),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:661:17
    |
661 |                 student::deleted_at::set(None),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`
help: consider importing this module
    |
518 +     use crate::school_test::grade::deleted_at;
    |
help: if you import `deleted_at`, refer to it directly
    |
661 -                 student::deleted_at::set(None),
661 +                 deleted_at::set(None),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:671:13
    |
671 |             student::id::equals(student.id),
    |             ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`
help: consider importing this module
    |
518 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
671 -             student::id::equals(student.id),
671 +             id::equals(student.id),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:672:13
    |
672 |             course::id::equals(course.id),
    |             ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
672 -             course::id::equals(course.id),
672 +             core::id::equals(course.id),
    |
help: consider importing this module
    |
518 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
672 -             course::id::equals(course.id),
672 +             id::equals(course.id),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
   --> caustics/tests/school_test.rs:675:17
    |
675 |                 enrollment::deleted_at::set(None),
    |                 ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
    |
    = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`
help: consider importing this module
    |
518 +     use crate::school_test::grade::deleted_at;
    |
help: if you import `deleted_at`, refer to it directly
    |
675 -                 enrollment::deleted_at::set(None),
675 +                 deleted_at::set(None),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
   --> caustics/tests/school_test.rs:680:62
    |
680 |         let enrollments = client.enrollment().find_many(vec![enrollment::student_id::equals(student.id)])
    |                                                              ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
    |
    = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`
help: consider importing this module
    |
518 +     use crate::school_test::grade::student_id;
    |
help: if you import `student_id`, refer to it directly
    |
680 -         let enrollments = client.enrollment().find_many(vec![enrollment::student_id::equals(student.id)])
680 +         let enrollments = client.enrollment().find_many(vec![student_id::equals(student.id)])
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:802:149
    |
802 | ..., true, fixed_now(), fixed_now(), department::id::equals(dept.id), vec![]
    |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
802 -             "T002".to_string(), "Eve".to_string(), "Newton".to_string(), "eve@school.edu".to_string(), fixed_now(), true, fixed_now(), fixed_now(), department::id::equals(dept.id), vec![]
802 +             "T002".to_string(), "Eve".to_string(), "Newton".to_string(), "eve@school.edu".to_string(), fixed_now(), true, fixed_now(), fixed_now(), id::equals(dept.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
   --> caustics/tests/school_test.rs:806:97
    |
806 | ... 40, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.i...
    |                                         ^^^^^^^ use of unresolved module or unlinked crate `teacher`
    |
    = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
806 -             "SCI101".to_string(), "Physics".to_string(), 5, 40, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
806 +             "SCI101".to_string(), "Physics".to_string(), 5, 40, true, fixed_now(), fixed_now(), id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:806:130
    |
806 | ... teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
    |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
806 -             "SCI101".to_string(), "Physics".to_string(), 5, 40, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
806 +             "SCI101".to_string(), "Physics".to_string(), 5, 40, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), id::equals(dept.id), semester::id::equals(semester.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
   --> caustics/tests/school_test.rs:806:163
    |
806 | ...), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
    |                                        ^^^^^^^^ use of unresolved module or unlinked crate `semester`
    |
    = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
806 -             "SCI101".to_string(), "Physics".to_string(), 5, 40, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
806 +             "SCI101".to_string(), "Physics".to_string(), 5, 40, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), department::id::equals(dept.id), id::equals(semester.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:814:76
    |
814 | ...   fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), course::id::equals(course.id), vec![]
    |                                                                      ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
814 -             fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), course::id::equals(course.id), vec![]
814 +             fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), id::equals(student.id), course::id::equals(course.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:814:109
    |
814 | ...w(), student::id::equals(student.id), course::id::equals(course.id), vec![]
    |                                          ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
814 -             fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), course::id::equals(course.id), vec![]
814 +             fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), core::id::equals(course.id), vec![]
    |
help: consider importing this module
    |
724 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
814 -             fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), course::id::equals(course.id), vec![]
814 +             fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), id::equals(course.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:818:59
    |
818 |         let course_with_rel = client.course().find_unique(course::id::equals(course.id))
    |                                                           ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
818 -         let course_with_rel = client.course().find_unique(course::id::equals(course.id))
818 +         let course_with_rel = client.course().find_unique(core::id::equals(course.id))
    |
help: consider importing this module
    |
724 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
818 -         let course_with_rel = client.course().find_unique(course::id::equals(course.id))
818 +         let course_with_rel = client.course().find_unique(id::equals(course.id))
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:819:19
    |
819 |             .with(course::teacher::fetch())
    |                   ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
819 -             .with(course::teacher::fetch())
819 +             .with(core::teacher::fetch())
    |
help: consider importing this module
    |
724 +     use crate::school_test::grade::teacher;
    |
help: if you import `teacher`, refer to it directly
    |
819 -             .with(course::teacher::fetch())
819 +             .with(teacher::fetch())
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:837:47
    |
837 | ...   let updated = client.student().update(student::id::equals(student.id), vec![student::email::set(Some("nullable@school.edu".to_strin...
    |                                             ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
837 -         let updated = client.student().update(student::id::equals(student.id), vec![student::email::set(Some("nullable@school.edu".to_string()))])
837 +         let updated = client.student().update(id::equals(student.id), vec![student::email::set(Some("nullable@school.edu".to_string()))])
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:841:48
    |
841 |         let updated2 = client.student().update(student::id::equals(student.id), vec![student::email::set(None)])
    |                                                ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
841 -         let updated2 = client.student().update(student::id::equals(student.id), vec![student::email::set(None)])
841 +         let updated2 = client.student().update(id::equals(student.id), vec![student::email::set(None)])
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:864:159
    |
864 | ..., true, fixed_now(), fixed_now(), department::id::equals(dept.id), vec![]
    |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
864 -                 "T003".to_string(), "Frank".to_string(), "Einstein".to_string(), "frank@school.edu".to_string(), fixed_now(), true, fixed_now(), fixed_now(), department::id::equals(dept.id), vec![]
864 +                 "T003".to_string(), "Frank".to_string(), "Einstein".to_string(), "frank@school.edu".to_string(), fixed_now(), true, fixed_now(), fixed_now(), id::equals(dept.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
   --> caustics/tests/school_test.rs:868:101
    |
868 | ... 20, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.i...
    |                                         ^^^^^^^ use of unresolved module or unlinked crate `teacher`
    |
    = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
868 -                 "TXN101".to_string(), "Quantum".to_string(), 4, 20, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
868 +                 "TXN101".to_string(), "Quantum".to_string(), 4, 20, true, fixed_now(), fixed_now(), id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:868:134
    |
868 | ... teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
    |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
868 -                 "TXN101".to_string(), "Quantum".to_string(), 4, 20, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
868 +                 "TXN101".to_string(), "Quantum".to_string(), 4, 20, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), id::equals(dept.id), semester::id::equals(semester.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
   --> caustics/tests/school_test.rs:868:167
    |
868 | ...), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
    |                                        ^^^^^^^^ use of unresolved module or unlinked crate `semester`
    |
    = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
868 -                 "TXN101".to_string(), "Quantum".to_string(), 4, 20, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
868 +                 "TXN101".to_string(), "Quantum".to_string(), 4, 20, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), department::id::equals(dept.id), id::equals(semester.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:872:80
    |
872 | ...   fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), course::id::equals(course.id), vec![]
    |                                                                      ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
872 -                 fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), course::id::equals(course.id), vec![]
872 +                 fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), id::equals(student.id), course::id::equals(course.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:872:113
    |
872 | ...w(), student::id::equals(student.id), course::id::equals(course.id), vec![]
    |                                          ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
872 -                 fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), course::id::equals(course.id), vec![]
872 +                 fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), core::id::equals(course.id), vec![]
    |
help: consider importing this module
    |
724 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
872 -                 fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), course::id::equals(course.id), vec![]
872 +                 fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), id::equals(course.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:880:17
    |
880 |                 student::id::equals(student.id),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
880 -                 student::id::equals(student.id),
880 +                 id::equals(student.id),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:881:17
    |
881 |                 course::id::equals(course.id),
    |                 ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
881 -                 course::id::equals(course.id),
881 +                 core::id::equals(course.id),
    |
help: consider importing this module
    |
724 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
881 -                 course::id::equals(course.id),
881 +                 id::equals(course.id),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
   --> caustics/tests/school_test.rs:882:17
    |
882 |                 teacher::id::equals(teacher.id),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `teacher`
    |
    = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`
help: consider importing this module
    |
724 +     use crate::school_test::grade::id;
    |
help: if you import `id`, refer to it directly
    |
882 -                 teacher::id::equals(teacher.id),
882 +                 id::equals(teacher.id),
    |

error: could not compile `caustics` (test "school_test") due to 122 previous errors
error: could not compile `caustics` (test "mod") due to 184 previous errors
