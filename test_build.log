    Blocking waiting for file lock on build directory
   Compiling caustics-macros v0.1.0 (/home/adriano/Sviluppo/caustics/caustics-macros)
warning: unused import: `crate::where_param::generate_where_param_logic`
 --> caustics-macros/src/entity.rs:6:5
  |
6 | use crate::where_param::generate_where_param_logic;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: `caustics-macros` (lib test) generated 1 warning (run `cargo fix --lib -p caustics-macros --tests` to apply 1 suggestion)
warning: `caustics-macros` (lib) generated 1 warning (1 duplicate)
   Compiling caustics v0.1.0 (/home/adriano/Sviluppo/caustics/caustics)
Parse error: expected one of: identifier, `::`, `<`, `_`, literal, `const`, `ref`, `mut`, `&`, parentheses, square brackets, `..`, `const`
error: Failed to parse generated items: expected one of: identifier, `::`, `<`, `_`, literal, `const`, `ref`, `mut`, `&`, parentheses, square brackets, `..`, `const`
 --> caustics/tests/blog_test.rs:5:1
  |
5 | #[caustics(namespace = "blog")]
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

Parse error: expected one of: identifier, `::`, `<`, `_`, literal, `const`, `ref`, `mut`, `&`, parentheses, square brackets, `..`, `const`
error: Failed to parse generated items: expected one of: identifier, `::`, `<`, `_`, literal, `const`, `ref`, `mut`, `&`, parentheses, square brackets, `..`, `const`
 --> caustics/tests/school_test.rs:5:1
  |
5 | #[caustics(namespace = "school")]
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

Parse error: expected one of: identifier, `::`, `<`, `_`, literal, `const`, `ref`, `mut`, `&`, parentheses, square brackets, `..`, `const`
error: Failed to parse generated items: expected one of: identifier, `::`, `<`, `_`, literal, `const`, `ref`, `mut`, `&`, parentheses, square brackets, `..`, `const`
  --> caustics/tests/blog_test.rs:44:1
   |
44 | #[caustics(namespace = "blog")]
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

Parse error: expected one of: identifier, `::`, `<`, `_`, literal, `const`, `ref`, `mut`, `&`, parentheses, square brackets, `..`, `const`
Parse error: expected one of: identifier, `::`, `<`, `_`, literal, `const`, `ref`, `mut`, `&`, parentheses, square brackets, `..`, `const`
error: Failed to parse generated items: expected one of: identifier, `::`, `<`, `_`, literal, `const`, `ref`, `mut`, `&`, parentheses, square brackets, `..`, `const`
  --> caustics/tests/school_test.rs:63:1
   |
63 | #[caustics(namespace = "school")]
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

Parse error: expected one of: identifier, `::`, `<`, `_`, literal, `const`, `ref`, `mut`, `&`, parentheses, square brackets, `..`, `const`
Parse error: expected one of: identifier, `::`, `<`, `_`, literal, `const`, `ref`, `mut`, `&`, parentheses, square brackets, `..`, `const`
error: Failed to parse generated items: expected one of: identifier, `::`, `<`, `_`, literal, `const`, `ref`, `mut`, `&`, parentheses, square brackets, `..`, `const`
   --> caustics/tests/school_test.rs:124:1
    |
124 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

Parse error: expected one of: identifier, `::`, `<`, `_`, literal, `const`, `ref`, `mut`, `&`, parentheses, square brackets, `..`, `const`
Parse error: expected one of: identifier, `::`, `<`, `_`, literal, `const`, `ref`, `mut`, `&`, parentheses, square brackets, `..`, `const`
error: Failed to parse generated items: expected one of: identifier, `::`, `<`, `_`, literal, `const`, `ref`, `mut`, `&`, parentheses, square brackets, `..`, `const`
   --> caustics/tests/school_test.rs:174:1
    |
174 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

Parse error: expected one of: identifier, `::`, `<`, `_`, literal, `const`, `ref`, `mut`, `&`, parentheses, square brackets, `..`, `const`
Parse error: expected one of: identifier, `::`, `<`, `_`, literal, `const`, `ref`, `mut`, `&`, parentheses, square brackets, `..`, `const`
error: Failed to parse generated items: expected one of: identifier, `::`, `<`, `_`, literal, `const`, `ref`, `mut`, `&`, parentheses, square brackets, `..`, `const`
   --> caustics/tests/school_test.rs:275:1
    |
275 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

Parse error: expected one of: identifier, `::`, `<`, `_`, literal, `const`, `ref`, `mut`, `&`, parentheses, square brackets, `..`, `const`
Parse error: expected one of: identifier, `::`, `<`, `_`, literal, `const`, `ref`, `mut`, `&`, parentheses, square brackets, `..`, `const`
error[E0432]: unresolved imports `super::post`, `super::user`
  --> caustics/tests/blog_test.rs:98:17
   |
98 |     use super::{post, user};
   |                 ^^^^  ^^^^ no `user` in the root
   |                 |
   |                 no `post` in the root

Parse error: expected one of: identifier, `::`, `<`, `_`, literal, `const`, `ref`, `mut`, `&`, parentheses, square brackets, `..`, `const`
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:3102
  |
1 | ...ityClient < '_ , DatabaseConnection > { user :: EntityClient :: new (& * self . db) } pub fn post (& self) -> post :: EntityClient < '...
  |                                            ^^^^ use of unresolved module or unlinked crate `user`
  |
  = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:3223
  |
1 | ...ityClient < '_ , DatabaseConnection > { post :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCaustics...
  |                                            ^^^^ use of unresolved module or unlinked crate `post`
  |
  = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:3487
  |
1 | ...tyClient < '_ , DatabaseTransaction > { user :: EntityClient :: new (& * self . tx) } pub fn post (& self) -> post :: EntityClient < '...
  |                                            ^^^^ use of unresolved module or unlinked crate `user`
  |
  = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

Parse error: expected one of: identifier, `::`, `<`, `_`, literal, `const`, `ref`, `mut`, `&`, parentheses, square brackets, `..`, `const`
error: Failed to parse generated items: expected one of: identifier, `::`, `<`, `_`, literal, `const`, `ref`, `mut`, `&`, parentheses, square brackets, `..`, `const`
   --> caustics/tests/school_test.rs:409:1
    |
409 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:3609
  |
1 | ...tyClient < '_ , DatabaseTransaction > { post :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F...
  |                                            ^^^^ use of unresolved module or unlinked crate `post`
  |
  = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:159:26
    |
159 |             .find_unique(user::id::equals(1))
    |                          ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:168:30
    |
168 |             .find_first(vec![user::name::equals("John"), user::age::gt(18)])
    |                              ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:168:58
    |
168 |             .find_first(vec![user::name::equals("John"), user::age::gt(18)])
    |                                                          ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:177:29
    |
177 |             .find_many(vec![user::age::gt(18)])
    |                             ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:198:22
    |
198 |                 vec![user::age::set(Some(25)), user::deleted_at::set(None)],
    |                      ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

Parse error: expected one of: identifier, `::`, `<`, `_`, literal, `const`, `ref`, `mut`, `&`, parentheses, square brackets, `..`, `const`
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:198:48
    |
198 |                 vec![user::age::set(Some(25)), user::deleted_at::set(None)],
    |                                                ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:206:30
    |
206 |             .find_first(vec![user::email::equals(&email)])
    |                              ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:222:17
    |
222 |                 user::id::equals(user.id),
    |                 ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:223:22
    |
223 |                 vec![post::content::set(Some(
    |                      ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:233:30
    |
233 |             .find_first(vec![post::id::equals(post.id)])
    |                              ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:260:22
    |
260 |                 vec![user::age::set(Some(25)), user::deleted_at::set(None)],
    |                      ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:260:48
    |
260 |                 vec![user::age::set(Some(25)), user::deleted_at::set(None)],
    |                                                ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:270:17
    |
270 |                 user::id::equals(user.id),
    |                 ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:271:22
    |
271 |                 vec![user::name::set("John Doe"), user::age::set(Some(26))],
    |                      ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:271:51
    |
271 |                 vec![user::name::set("John Doe"), user::age::set(Some(26))],
    |                                                   ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:294:26
    |
294 |                     vec![user::age::set(Some(20 + i)), user::deleted_at::set(None)],
    |                          ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:294:56
    |
294 |                     vec![user::age::set(Some(20 + i)), user::deleted_at::set(None)],
    |                                                        ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:307:23
    |
307 |             .order_by(user::age::order(SortOrder::Desc))
    |                       ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0432]: unresolved imports `super::student`, `super::teacher`, `super::department`, `super::course`, `super::enrollment`, `super::semester`
   --> caustics/tests/school_test.rs:453:17
    |
453 |     use super::{student, teacher, department, course, enrollment, grade, semester};
    |                 ^^^^^^^  ^^^^^^^  ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^         ^^^^^^^^ no `semester` in the root
    |                 |        |        |           |       |
    |                 |        |        |           |       no `enrollment` in the root
    |                 |        |        |           no `course` in the root
    |                 |        |        no `department` in the root
    |                 |        no `teacher` in the root
    |                 no `student` in the root
    |
    = help: consider importing this module instead:
            crate::grade::student
    = help: consider importing this module instead:
            crate::grade::teacher
    = help: consider importing this module instead:
            crate::grade::course

error[E0432]: unresolved import `crate`
   --> caustics/tests/school_test.rs:332:1
    |
332 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    | |
    | unresolved import
    | help: a similar path exists: `caustics::types`
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0432]: unresolved import `super::student`
   --> caustics/tests/school_test.rs:727:13
    |
727 |         use super::student;
    |             ^^^^^^^^^^^^^^ no `student` in the root
    |
help: consider importing this module instead
    |
727 -         use super::student;
727 +         use crate::grade::student;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:331:22
    |
331 |                 vec![user::age::set(Some(25)), user::deleted_at::set(None)],
    |                      ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:331:48
    |
331 |                 vec![user::age::set(Some(25)), user::deleted_at::set(None)],
    |                                                ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:340:21
    |
340 |             .delete(user::id::equals(user.id))
    |                     ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:348:26
    |
348 |             .find_unique(user::id::equals(user.id))
    |                          ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:364:17
    |
364 |                 user::email::equals("john@example.com"),
    |                 ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0432]: unresolved imports `super::post`, `super::user`
  --> caustics/tests/blog_test.rs:98:17
   |
98 |     use super::{post, user};
   |                 ^^^^  ^^^^ no `user` in `blog_test`
   |                 |
   |                 no `post` in `blog_test`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:372:22
    |
372 |                 vec![user::name::set("John"), user::age::set(25)],
    |                      ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0432]: unresolved imports `super::student`, `super::teacher`, `super::department`, `super::course`, `super::enrollment`, `super::semester`
   --> caustics/tests/school_test.rs:453:17
    |
453 |     use super::{student, teacher, department, course, enrollment, grade, semester};
    |                 ^^^^^^^  ^^^^^^^  ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^         ^^^^^^^^ no `semester` in `school_test`
    |                 |        |        |           |       |
    |                 |        |        |           |       no `enrollment` in `school_test`
    |                 |        |        |           no `course` in `school_test`
    |                 |        |        no `department` in `school_test`
    |                 |        no `teacher` in `school_test`
    |                 no `student` in `school_test`
    |
    = help: consider importing this module instead:
            crate::school_test::grade::student
    = help: consider importing this module instead:
            crate::school_test::grade::teacher
    = help: consider importing this module instead:
            crate::school_test::grade::course

error[E0432]: unresolved import `super::student`
   --> caustics/tests/school_test.rs:727:13
    |
727 |         use super::student;
    |             ^^^^^^^^^^^^^^ no `student` in `school_test`
    |
help: consider importing this module instead
    |
727 -         use super::student;
727 +         use crate::school_test::grade::student;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:372:47
    |
372 |                 vec![user::name::set("John"), user::age::set(25)],
    |                                               ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:384:17
    |
384 |                 user::email::equals("john@example.com"),
    |                 ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:392:22
    |
392 |                 vec![user::name::set("John Doe"), user::age::set(26)],
    |                      ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:392:51
    |
392 |                 vec![user::name::set("John Doe"), user::age::set(26)],
    |                                                   ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:432:29
    |
432 | ...                   user::id::equals(user.id),
    |                       ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:433:34
    |
433 | ...                   vec![post::content::set("This is my first post".to_string())],
    |                            ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:450:30
    |
450 |             .find_first(vec![user::email::equals(&email_for_check)])
    |                              ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:493:30
    |
493 |             .find_first(vec![user::email::equals(&email_for_check)])
    |                              ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:540:17
    |
540 |                 user::email::equals(author.email),
    |                 ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:542:21
    |
542 |                     post::content::set("This post has been reviewed".to_string()),
    |                     ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:543:21
    |
543 |                     post::reviewer::connect(user::id::equals(reviewer.id)),
    |                     ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:543:45
    |
543 |                     post::reviewer::connect(user::id::equals(reviewer.id)),
    |                                             ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:556:17
    |
556 |                 user::id::equals(author.id),
    |                 ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:558:21
    |
558 |                     post::content::set("This post hasn't been reviewed yet".to_string()),
    |                     ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:568:26
    |
568 |             .find_unique(user::id::equals(author.id))
    |                          ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `student` in the crate root
   --> caustics/tests/school_test.rs:360:54
    |
360 |     #[derive(Caustics, Copy, Clone, Debug, EnumIter, DeriveRelation)]
    |                                                      ^^^^^^^^^^^^^^ could not find `student` in the crate root
    |
    = note: this error originates in the derive macro `DeriveRelation` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:569:19
    |
569 |             .with(user::posts::fetch(vec![]))
    |                   ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:582:26
    |
582 |             .find_unique(post::id::equals(post_with_reviewer.id))
    |                          ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `course` in the crate root
   --> caustics/tests/school_test.rs:360:54
    |
360 |     #[derive(Caustics, Copy, Clone, Debug, EnumIter, DeriveRelation)]
    |                                                      ^^^^^^^^^^^^^^ could not find `course` in the crate root
    |
    = note: this error originates in the derive macro `DeriveRelation` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:583:19
    |
583 |             .with(post::reviewer::fetch())
    |                   ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:595:26
    |
595 |             .find_unique(post::id::equals(post_without_reviewer.id))
    |                          ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `teacher` in the crate root
   --> caustics/tests/school_test.rs:360:54
    |
360 |     #[derive(Caustics, Copy, Clone, Debug, EnumIter, DeriveRelation)]
    |                                                      ^^^^^^^^^^^^^^ could not find `teacher` in the crate root
    |
    = note: this error originates in the derive macro `DeriveRelation` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:596:19
    |
596 |             .with(post::reviewer::fetch())
    |                   ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:618:26
    |
618 |                     vec![user::age::set(Some(25)), user::deleted_at::set(None)],
    |                          ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `student` in the crate root
   --> caustics/tests/school_test.rs:390:25
    |
390 |     impl Related<super::student::Entity> for Entity {
    |                         ^^^^^^^ could not find `student` in the crate root

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:618:52
    |
618 |                     vec![user::age::set(Some(25)), user::deleted_at::set(None)],
    |                                                    ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `course` in the crate root
   --> caustics/tests/school_test.rs:396:25
    |
396 |     impl Related<super::course::Entity> for Entity {
    |                         ^^^^^^ could not find `course` in the crate root

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:625:26
    |
625 |                     vec![user::age::set(Some(30))],
    |                          ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `teacher` in the crate root
   --> caustics/tests/school_test.rs:402:25
    |
402 |     impl Related<super::teacher::Entity> for Entity {
    |                         ^^^^^^^ could not find `teacher` in the crate root

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:651:18
    |
651 |             vec![user::age::set(Some(30)), user::deleted_at::set(None)],
    |                  ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `student` in the crate root
   --> caustics/tests/school_test.rs:332:1
    |
332 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `student` in the crate root
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:651:44
    |
651 |             vec![user::age::set(Some(30)), user::deleted_at::set(None)],
    |                                            ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:659:18
    |
659 |             vec![user::age::set(Some(28)), user::deleted_at::set(None)],
    |                  ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `course` in the crate root
   --> caustics/tests/school_test.rs:332:1
    |
332 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `course` in the crate root
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:659:44
    |
659 |             vec![user::age::set(Some(28)), user::deleted_at::set(None)],
    |                                            ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `teacher` in the crate root
   --> caustics/tests/school_test.rs:332:1
    |
332 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `teacher` in the crate root
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:667:18
    |
667 |             vec![user::age::set(Some(40)), user::deleted_at::set(None)],
    |                  ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:667:44
    |
667 |             vec![user::age::set(Some(40)), user::deleted_at::set(None)],
    |                                            ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:672:29
    |
672 |             .find_many(vec![user::name::contains("Doe")])
    |                             ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:681:29
    |
681 |             .find_many(vec![user::name::starts_with("J")])
    |                             ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:690:29
    |
690 |             .find_many(vec![user::name::ends_with("son")])
    |                             ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:699:29
    |
699 |             .find_many(vec![user::email::contains("example.com")])
    |                             ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:706:29
    |
706 |             .find_many(vec![user::email::ends_with("test.org")])
    |                             ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:727:18
    |
727 |             vec![user::age::set(Some(25)), user::deleted_at::set(None)],
    |                  ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:727:44
    |
727 |             vec![user::age::set(Some(25)), user::deleted_at::set(None)],
    |                                            ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:735:18
    |
735 |             vec![user::age::set(Some(30)), user::deleted_at::set(None)],
    |                  ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:735:44
    |
735 |             vec![user::age::set(Some(30)), user::deleted_at::set(None)],
    |                                            ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:743:18
    |
743 |             vec![user::age::set(Some(35)), user::deleted_at::set(None)],
    |                  ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:743:44
    |
743 |             vec![user::age::set(Some(35)), user::deleted_at::set(None)],
    |                                            ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:748:29
    |
748 |             .find_many(vec![user::age::gt(25)])
    |                             ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:757:29
    |
757 |             .find_many(vec![user::age::gte(30)])
    |                             ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:766:29
    |
766 |             .find_many(vec![user::age::lt(35)])
    |                             ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:775:29
    |
775 |             .find_many(vec![user::age::lte(30)])
    |                             ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:785:29
    |
785 |             .find_many(vec![user::created_at::lt(future_date)])
    |                             ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:793:29
    |
793 |             .find_many(vec![user::name::gt("J")])
    |                             ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:805:17
    |
805 |                 user::age::gte(25),
    |                 ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:806:17
    |
806 |                 user::age::lte(35),
    |                 ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:825:18
    |
825 |             vec![user::age::set(Some(40)), user::deleted_at::set(Some(deleted_time))],
    |                  ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:825:44
    |
825 |             vec![user::age::set(Some(40)), user::deleted_at::set(Some(deleted_time))],
    |                                            ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:830:29
    |
830 |             .find_many(vec![user::deleted_at::gt(now + chrono::Duration::days(1))])
    |                             ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:837:29
    |
837 |             .find_many(vec![user::deleted_at::lte(deleted_time)])
    |                             ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:848:13
    |
848 |             user::id::equals(1),
    |             ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:849:18
    |
849 |             vec![post::content::set(Some("Hello".to_string()))],
    |                  ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:855:13
    |
855 |             user::id::equals(1),
    |             ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:856:18
    |
856 |             vec![post::content::set(Some("World".to_string()))],
    |                  ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:862:13
    |
862 |             user::id::equals(1),
    |             ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:863:18
    |
863 |             vec![post::content::set(None)],
    |                  ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:868:29
    |
868 |             .find_many(vec![post::content::gt(Some("Hello".to_string()))])
    |                             ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:874:29
    |
874 |             .find_many(vec![post::content::lte(Some("World".to_string()))])
    |                             ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:881:29
    |
881 |             .find_many(vec![post::content::lt(Some("World".to_string()))])
    |                             ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
   --> caustics/tests/blog_test.rs:887:29
    |
887 |             .find_many(vec![post::content::gte(Some("Hello".to_string()))])
    |                             ^^^^ use of unresolved module or unlinked crate `post`
    |
    = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: unresolved import
   --> caustics/tests/school_test.rs:332:1
    |
332 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    | |
    | unresolved import
    | help: a similar path exists: `crate::grade::student`
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: unresolved import
   --> caustics/tests/school_test.rs:332:1
    |
332 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    | |
    | unresolved import
    | help: a similar path exists: `crate::grade::course`
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: unresolved import
   --> caustics/tests/school_test.rs:332:1
    |
332 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    | |
    | unresolved import
    | help: a similar path exists: `crate::grade::teacher`
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:685
  |
1 | ...{ match entity_name { "user" => Some (& user :: EntityFetcherImpl) , "post" => Some (& post :: EntityFetcherImpl) , _ => None , } } } ...
  |                                            ^^^^ use of unresolved module or unlinked crate `user`
  |
  = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:732
  |
1 | ... EntityFetcherImpl) , "post" => Some (& post :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityR...
  |                                            ^^^^ use of unresolved module or unlinked crate `post`
  |
  = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:536:17
    |
536 |                 student::email::set(Some("alice@example.com".to_string())),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:537:17
    |
537 |                 student::phone::set(Some("123456789".to_string())),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:538:17
    |
538 |                 student::graduation_date::set(None),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:539:17
    |
539 |                 student::deleted_at::set(None),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:551:50
    |
551 |         let found = client.student().find_unique(student::student_number::equals("S12345".to_string()))
    |                                                  ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:569:17
    |
569 |                 department::description::set(Some("CS Dept".to_string())),
    |                 ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:570:17
    |
570 |                 department::deleted_at::set(None),
    |                 ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
   --> caustics/tests/school_test.rs:608:18
    |
608 |             vec![semester::deleted_at::set(None)],
    |                  ^^^^^^^^ use of unresolved module or unlinked crate `semester`
    |
    = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:621:13
    |
621 |             department::id::equals(dept.id),
    |             ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
   --> caustics/tests/school_test.rs:623:17
    |
623 |                 teacher::phone::set(None),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `teacher`
    |
    = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
   --> caustics/tests/school_test.rs:624:17
    |
624 |                 teacher::termination_date::set(None),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `teacher`
    |
    = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
   --> caustics/tests/school_test.rs:625:17
    |
625 |                 teacher::deleted_at::set(None),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `teacher`
    |
    = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
   --> caustics/tests/school_test.rs:638:13
    |
638 |             teacher::id::equals(teacher.id),
    |             ^^^^^^^ use of unresolved module or unlinked crate `teacher`
    |
    = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:639:13
    |
639 |             department::id::equals(dept.id),
    |             ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
   --> caustics/tests/school_test.rs:640:13
    |
640 |             semester::id::equals(semester.id),
    |             ^^^^^^^^ use of unresolved module or unlinked crate `semester`
    |
    = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:642:17
    |
642 |                 course::description::set(None),
    |                 ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
642 -                 course::description::set(None),
642 +                 core::description::set(None),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:643:17
    |
643 |                 course::deleted_at::set(None),
    |                 ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
643 -                 course::deleted_at::set(None),
643 +                 core::deleted_at::set(None),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:658:17
    |
658 |                 student::email::set(Some("charlie@school.edu".to_string())),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:659:17
    |
659 |                 student::phone::set(None),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:660:17
    |
660 |                 student::graduation_date::set(None),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:661:17
    |
661 |                 student::deleted_at::set(None),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:671:13
    |
671 |             student::id::equals(student.id),
    |             ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:672:13
    |
672 |             course::id::equals(course.id),
    |             ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
672 -             course::id::equals(course.id),
672 +             core::id::equals(course.id),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
   --> caustics/tests/school_test.rs:674:17
    |
674 |                 enrollment::withdrawal_date::set(None),
    |                 ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
    |
    = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
   --> caustics/tests/school_test.rs:675:17
    |
675 |                 enrollment::deleted_at::set(None),
    |                 ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
    |
    = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
   --> caustics/tests/school_test.rs:684:62
    |
684 |         let enrollments = client.enrollment().find_many(vec![enrollment::student_id::equals(student.id)])
    |                                                              ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
    |
    = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:720:47
    |
720 |         let s3 = client.student().find_unique(student::student_number::equals("S3".to_string()))
    |                                               ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:778:13
    |
778 |             student::student_number::equals("U1".to_string()),
    |             ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:791:17
    |
791 |                 student::first_name::set("Updated".to_string()),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:818:13
    |
818 |             student::student_number::equals("S01".to_string()),
    |             ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:820:19
    |
820 |         .order_by(student::student_number::order(caustics::SortOrder::Asc))
    |                   ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:826:13
    |
826 |             student::student_number::equals("S02".to_string()),
    |             ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:828:19
    |
828 |         .order_by(student::student_number::order(caustics::SortOrder::Asc))
    |                   ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:848:149
    |
848 | ..., true, fixed_now(), fixed_now(), department::id::equals(dept.id), vec![]
    |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
   --> caustics/tests/school_test.rs:852:97
    |
852 | ... 40, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.i...
    |                                         ^^^^^^^ use of unresolved module or unlinked crate `teacher`
    |
    = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:852:130
    |
852 | ... teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
    |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
   --> caustics/tests/school_test.rs:852:163
    |
852 | ...), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
    |                                        ^^^^^^^^ use of unresolved module or unlinked crate `semester`
    |
    = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:385:17
    |
385 |                 user::Create {
    |                 ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
   --> caustics/tests/blog_test.rs:365:17
    |
365 |                 user::Create {
    |                 ^^^^ use of unresolved module or unlinked crate `user`
    |
    = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:3051
  |
1 | ...ts (results)) } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseConnection > { user :: EntityClient :: new (& * self . db)...
  |                                            ^^^^ use of unresolved module or unlinked crate `user`
  |
  = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:3172
  |
1 | ... * self . db) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseConnection > { post :: EntityClient :: new (& * self . db)...
  |                                            ^^^^ use of unresolved module or unlinked crate `post`
  |
  = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:3435
  |
1 | ...{ Self { tx } } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseTransaction > { user :: EntityClient :: new (& * self . tx...
  |                                            ^^^^ use of unresolved module or unlinked crate `user`
  |
  = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:3557
  |
1 | ... * self . tx) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseTransaction > { post :: EntityClient :: new (& * self . tx...
  |                                            ^^^^ use of unresolved module or unlinked crate `post`
  |
  = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`

Some errors have detailed explanations: E0432, E0433.
For more information about an error, try `rustc --explain E0432`.
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:860:76
    |
860 | ...   fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), course::id::equals(course.id), vec![]
    |                                                                      ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:860:109
    |
860 | ...w(), student::id::equals(student.id), course::id::equals(course.id), vec![]
    |                                          ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
860 -             fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), course::id::equals(course.id), vec![]
860 +             fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), core::id::equals(course.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:864:59
    |
864 |         let course_with_rel = client.course().find_unique(course::id::equals(course.id))
    |                                                           ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
864 -         let course_with_rel = client.course().find_unique(course::id::equals(course.id))
864 +         let course_with_rel = client.course().find_unique(core::id::equals(course.id))
    |

error: could not compile `caustics` (test "blog_test") due to 101 previous errors
warning: build failed, waiting for other jobs to finish...
error[E0433]: failed to resolve: could not find `student` in `super`
   --> caustics/tests/school_test.rs:360:54
    |
360 |     #[derive(Caustics, Copy, Clone, Debug, EnumIter, DeriveRelation)]
    |                                                      ^^^^^^^^^^^^^^ could not find `student` in `super`
    |
    = note: this error originates in the derive macro `DeriveRelation` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: could not find `course` in `super`
   --> caustics/tests/school_test.rs:360:54
    |
360 |     #[derive(Caustics, Copy, Clone, Debug, EnumIter, DeriveRelation)]
    |                                                      ^^^^^^^^^^^^^^ could not find `course` in `super`
    |
    = note: this error originates in the derive macro `DeriveRelation` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:866:19
    |
866 |             .with(course::department::fetch())
    |                   ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
866 -             .with(course::department::fetch())
866 +             .with(core::department::fetch())
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:867:19
    |
867 |             .with(course::enrollments::fetch(vec![]))
    |                   ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
867 -             .with(course::enrollments::fetch(vec![]))
867 +             .with(core::enrollments::fetch(vec![]))
    |

error[E0433]: failed to resolve: could not find `teacher` in `super`
   --> caustics/tests/school_test.rs:360:54
    |
360 |     #[derive(Caustics, Copy, Clone, Debug, EnumIter, DeriveRelation)]
    |                                                      ^^^^^^^^^^^^^^ could not find `teacher` in `super`
    |
    = note: this error originates in the derive macro `DeriveRelation` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:879:142
    |
879 | ...true, fixed_now(), fixed_now(), vec![student::email::set(None)]
    |                                         ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `student` in `super`
   --> caustics/tests/school_test.rs:390:25
    |
390 |     impl Related<super::student::Entity> for Entity {
    |                         ^^^^^^^ could not find `student` in `super`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:883:47
    |
883 | ...   let updated = client.student().update(student::id::equals(student.id), vec![student::email::set(Some("nullable@school.edu".to_strin...
    |                                             ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `course` in `super`
   --> caustics/tests/school_test.rs:396:25
    |
396 |     impl Related<super::course::Entity> for Entity {
    |                         ^^^^^^ could not find `course` in `super`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:883:85
    |
883 | ...tudent::id::equals(student.id), vec![student::email::set(Some("nullable@school.edu".to_string()))])
    |                                         ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `teacher` in `super`
   --> caustics/tests/school_test.rs:402:25
    |
402 |     impl Related<super::teacher::Entity> for Entity {
    |                         ^^^^^^^ could not find `teacher` in `super`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:887:48
    |
887 |         let updated2 = client.student().update(student::id::equals(student.id), vec![student::email::set(None)])
    |                                                ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `student` in `super`
   --> caustics/tests/school_test.rs:332:1
    |
332 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `student` in `super`
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:887:86
    |
887 |         let updated2 = client.student().update(student::id::equals(student.id), vec![student::email::set(None)])
    |                                                                                      ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `course` in `super`
   --> caustics/tests/school_test.rs:332:1
    |
332 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `course` in `super`
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:910:159
    |
910 | ..., true, fixed_now(), fixed_now(), department::id::equals(dept.id), vec![]
    |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `teacher` in `super`
   --> caustics/tests/school_test.rs:332:1
    |
332 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `teacher` in `super`
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
   --> caustics/tests/school_test.rs:914:101
    |
914 | ... 20, true, fixed_now(), fixed_now(), teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.i...
    |                                         ^^^^^^^ use of unresolved module or unlinked crate `teacher`
    |
    = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:914:134
    |
914 | ... teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
    |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
   --> caustics/tests/school_test.rs:914:167
    |
914 | ...), department::id::equals(dept.id), semester::id::equals(semester.id), vec![]
    |                                        ^^^^^^^^ use of unresolved module or unlinked crate `semester`
    |
    = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:918:80
    |
918 | ...   fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), course::id::equals(course.id), vec![]
    |                                                                      ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:918:113
    |
918 | ...w(), student::id::equals(student.id), course::id::equals(course.id), vec![]
    |                                          ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
918 -                 fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), course::id::equals(course.id), vec![]
918 +                 fixed_now(), "enrolled".to_string(), fixed_now(), fixed_now(), student::id::equals(student.id), core::id::equals(course.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:926:17
    |
926 |                 student::id::equals(student.id),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:927:17
    |
927 |                 course::id::equals(course.id),
    |                 ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
927 -                 course::id::equals(course.id),
927 +                 core::id::equals(course.id),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
   --> caustics/tests/school_test.rs:928:17
    |
928 |                 teacher::id::equals(teacher.id),
    |                 ^^^^^^^ use of unresolved module or unlinked crate `teacher`
    |
    = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: could not find `letter_grade` in `grade`
   --> caustics/tests/school_test.rs:929:29
    |
929 |                 vec![grade::letter_grade::set(None), grade::comments::set(None), grade::deleted_at::set(None)]
    |                             ^^^^^^^^^^^^ could not find `letter_grade` in `grade`

error[E0433]: failed to resolve: could not find `comments` in `grade`
   --> caustics/tests/school_test.rs:929:61
    |
929 |                 vec![grade::letter_grade::set(None), grade::comments::set(None), grade::deleted_at::set(None)]
    |                                                             ^^^^^^^^ could not find `comments` in `grade`

error[E0433]: failed to resolve: could not find `deleted_at` in `grade`
   --> caustics/tests/school_test.rs:929:89
    |
929 |                 vec![grade::letter_grade::set(None), grade::comments::set(None), grade::deleted_at::set(None)]
    |                                                                                         ^^^^^^^^^^ could not find `deleted_at` in `grade`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:936:50
    |
936 |         let found = client.student().find_unique(student::student_number::equals("S300".to_string())).exec().await.unwrap();
    |                                                  ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:953:124
    |
953 | ...to_string(), now, true, now, now, department::id::equals(dept.id), vec![]
    |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
   --> caustics/tests/school_test.rs:957:13
    |
957 |             teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id),
    |             ^^^^^^^ use of unresolved module or unlinked crate `teacher`
    |
    = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
   --> caustics/tests/school_test.rs:957:46
    |
957 |             teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id),
    |                                              ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
    |
    = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
   --> caustics/tests/school_test.rs:957:79
    |
957 |             teacher::id::equals(teacher.id), department::id::equals(dept.id), semester::id::equals(semester.id),
    |                                                                               ^^^^^^^^ use of unresolved module or unlinked crate `semester`
    |
    = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:969:52
    |
969 |             now, "enrolled".to_string(), now, now, student::id::equals(student1.id), course::id::equals(course.id), vec![]
    |                                                    ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:969:86
    |
969 |             now, "enrolled".to_string(), now, now, student::id::equals(student1.id), course::id::equals(course.id), vec![]
    |                                                                                      ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
969 -             now, "enrolled".to_string(), now, now, student::id::equals(student1.id), course::id::equals(course.id), vec![]
969 +             now, "enrolled".to_string(), now, now, student::id::equals(student1.id), core::id::equals(course.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:972:52
    |
972 |             now, "enrolled".to_string(), now, now, student::id::equals(student2.id), course::id::equals(course.id), vec![]
    |                                                    ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:972:86
    |
972 |             now, "enrolled".to_string(), now, now, student::id::equals(student2.id), course::id::equals(course.id), vec![]
    |                                                                                      ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
972 -             now, "enrolled".to_string(), now, now, student::id::equals(student2.id), course::id::equals(course.id), vec![]
972 +             now, "enrolled".to_string(), now, now, student::id::equals(student2.id), core::id::equals(course.id), vec![]
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:976:13
    |
976 |             course::id::equals(course.id),
    |             ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
976 -             course::id::equals(course.id),
976 +             core::id::equals(course.id),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:978:17
    |
978 |                 course::enrollments::connect(vec![
    |                 ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
978 -                 course::enrollments::connect(vec![
978 +                 core::enrollments::connect(vec![
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
   --> caustics/tests/school_test.rs:979:21
    |
979 |                     enrollment::id::equals(enrollment1.id),
    |                     ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
    |
    = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
   --> caustics/tests/school_test.rs:980:21
    |
980 |                     enrollment::id::equals(enrollment2.id),
    |                     ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
    |
    = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
   --> caustics/tests/school_test.rs:985:62
    |
985 |         let enrollments = client.enrollment().find_many(vec![enrollment::course_id::equals(course.id)])
    |                                                              ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
    |
    = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3393
  |
1 | ...Client < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClie...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `student`
  |
  = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3523
  |
1 | ...Client < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: Enti...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `teacher`
  |
  = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3659
  |
1 | ...ent < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
  |
  = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3790
  |
1 | ...yClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: Enti...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `course`
  |
  = help: if you wanted to use a crate named `course`, use `cargo add course` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3925
  |
1 | ...ent < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient <...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
  |
  = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4184
  |
1 | ...lient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCaustics...
  |                                        ^^^^^^^^ use of unresolved module or unlinked crate `semester`
  |
  = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4458
  |
1 | ...lient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClie...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `student`
  |
  = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4589
  |
1 | ...lient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: Enti...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `teacher`
  |
  = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4726
  |
1 | ...nt < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
  |
  = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4858
  |
1 | ...Client < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: Enti...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `course`
  |
  = help: if you wanted to use a crate named `course`, use `cargo add course` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4994
  |
1 | ...nt < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient <...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
  |
  = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:5255
  |
1 | ...ient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F...
  |                                        ^^^^^^^^ use of unresolved module or unlinked crate `semester`
  |
  = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: could not find `student` in the crate root
   --> caustics/tests/school_test.rs:360:54
    |
360 |     #[derive(Caustics, Copy, Clone, Debug, EnumIter, DeriveRelation)]
    |                                                      ^^^^^^^^^^^^^^ could not find `student` in the crate root
    |
    = note: this error originates in the derive macro `DeriveRelation` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing one of these items
    |
334 +     use sea_orm_migration::seaql_migrations::Column;
    |
334 +     use sqlx::Column;
    |

error[E0433]: failed to resolve: could not find `course` in the crate root
   --> caustics/tests/school_test.rs:360:54
    |
360 |     #[derive(Caustics, Copy, Clone, Debug, EnumIter, DeriveRelation)]
    |                                                      ^^^^^^^^^^^^^^ could not find `course` in the crate root
    |
    = note: this error originates in the derive macro `DeriveRelation` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing one of these items
    |
334 +     use sea_orm_migration::seaql_migrations::Column;
    |
334 +     use sqlx::Column;
    |

error[E0433]: failed to resolve: could not find `teacher` in the crate root
   --> caustics/tests/school_test.rs:360:54
    |
360 |     #[derive(Caustics, Copy, Clone, Debug, EnumIter, DeriveRelation)]
    |                                                      ^^^^^^^^^^^^^^ could not find `teacher` in the crate root
    |
    = note: this error originates in the derive macro `DeriveRelation` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing one of these items
    |
334 +     use sea_orm_migration::seaql_migrations::Column;
    |
334 +     use sqlx::Column;
    |

error[E0433]: failed to resolve: could not find `student` in the crate root
   --> caustics/tests/school_test.rs:332:1
    |
332 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `student` in the crate root
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing this struct
    |
334 +     use sea_orm_migration::seaql_migrations::Entity;
    |

error[E0433]: failed to resolve: could not find `course` in the crate root
   --> caustics/tests/school_test.rs:332:1
    |
332 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `course` in the crate root
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing this struct
    |
334 +     use sea_orm_migration::seaql_migrations::Entity;
    |

error[E0433]: failed to resolve: could not find `teacher` in the crate root
   --> caustics/tests/school_test.rs:332:1
    |
332 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `teacher` in the crate root
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing this struct
    |
334 +     use sea_orm_migration::seaql_migrations::Entity;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:865:19
    |
865 |             .with(course::teacher::fetch())
    |                   ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
865 -             .with(course::teacher::fetch())
865 +             .with(core::teacher::fetch())
    |
help: consider importing this module
    |
763 +     use crate::grade::teacher;
    |
help: if you import `teacher`, refer to it directly
    |
865 -             .with(course::teacher::fetch())
865 +             .with(teacher::fetch())
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:688
  |
1 | ...h entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department"...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `student`
  |
  = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:741
  |
1 | ...yFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "cours...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `teacher`
  |
  = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:797
  |
1 | ...erImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" =...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
  |
  = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:852
  |
1 | ...ityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `course`
  |
  = help: if you wanted to use a crate named `course`, use `cargo add course` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:907
  |
1 | ...erImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => So...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
  |
  = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:1013
  |
1 | ...etcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityR...
  |                                        ^^^^^^^^ use of unresolved module or unlinked crate `semester`
  |
  = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:3102
  |
1 | ...ityClient < '_ , DatabaseConnection > { user :: EntityClient :: new (& * self . db) } pub fn post (& self) -> post :: EntityClient < '...
  |                                            ^^^^ use of unresolved module or unlinked crate `user`
  |
  = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "user" => Some (& user :: EntityFetcherImpl) , "post" => Some (& post :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseConnection > { user :: EntityClient :: new (& * self . db) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseConnection > { post :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseTransaction > { user :: EntityClient :: new (& * self . tx) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseTransaction > { post :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "user" => Some (& user :: EntityFetcherImpl) , "post" => Some (& post :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseConnection > { post :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseTransaction > { user :: EntityClient :: new (& * self . tx) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseTransaction > { post :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:3223
  |
1 | ...ityClient < '_ , DatabaseConnection > { post :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCaustics...
  |                                            ^^^^ use of unresolved module or unlinked crate `post`
  |
  = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "user" => Some (& user :: EntityFetcherImpl) , "post" => Some (& post :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseConnection > { user :: EntityClient :: new (& * self . db) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseConnection > { post :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseTransaction > { user :: EntityClient :: new (& * self . tx) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseTransaction > { post :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "user" => Some (& user :: EntityFetcherImpl) , "post" => Some (& post :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseConnection > { user :: EntityClient :: new (& * self . db) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseTransaction > { user :: EntityClient :: new (& * self . tx) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseTransaction > { post :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `user`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:3487
  |
1 | ...tyClient < '_ , DatabaseTransaction > { user :: EntityClient :: new (& * self . tx) } pub fn post (& self) -> post :: EntityClient < '...
  |                                            ^^^^ use of unresolved module or unlinked crate `user`
  |
  = help: if you wanted to use a crate named `user`, use `cargo add user` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "user" => Some (& user :: EntityFetcherImpl) , "post" => Some (& post :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseConnection > { user :: EntityClient :: new (& * self . db) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseConnection > { post :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseTransaction > { user :: EntityClient :: new (& * self . tx) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseTransaction > { post :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "user" => Some (& user :: EntityFetcherImpl) , "post" => Some (& post :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseConnection > { user :: EntityClient :: new (& * self . db) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseConnection > { post :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseTransaction > { post :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `post`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_blog_test.rs:1:3609
  |
1 | ...tyClient < '_ , DatabaseTransaction > { post :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F...
  |                                            ^^^^ use of unresolved module or unlinked crate `post`
  |
  = help: if you wanted to use a crate named `post`, use `cargo add post` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "user" => Some (& user :: EntityFetcherImpl) , "post" => Some (& post :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseConnection > { user :: EntityClient :: new (& * self . db) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseConnection > { post :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseTransaction > { user :: EntityClient :: new (& * self . tx) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseTransaction > { post :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "user" => Some (& user :: EntityFetcherImpl) , "post" => Some (& post :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseConnection > { user :: EntityClient :: new (& * self . db) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseConnection > { post :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn user (& self) -> user :: EntityClient < '_ , DatabaseTransaction > { user :: EntityClient :: new (& * self . tx) } pub fn post (& self) -> post :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3393
  |
1 | ...Client < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClie...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `student`
  |
  = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3523
  |
1 | ...Client < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: Enti...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `teacher`
  |
  = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3659
  |
1 | ...ent < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
  |
  = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3790
  |
1 | ...yClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: Enti...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `course`
  |
  = help: if you wanted to use a crate named `course`, use `cargo add course` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3925
  |
1 | ...ent < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient <...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
  |
  = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4184
  |
1 | ...lient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCaustics...
  |                                        ^^^^^^^^ use of unresolved module or unlinked crate `semester`
  |
  = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4458
  |
1 | ...lient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClie...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `student`
  |
  = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4589
  |
1 | ...lient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: Enti...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `teacher`
  |
  = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4726
  |
1 | ...nt < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
  |
  = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4858
  |
1 | ...Client < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: Enti...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `course`
  |
  = help: if you wanted to use a crate named `course`, use `cargo add course` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4994
  |
1 | ...nt < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient <...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
  |
  = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:5255
  |
1 | ...ient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F...
  |                                        ^^^^^^^^ use of unresolved module or unlinked crate `semester`
  |
  = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`
help: consider importing this struct
  |
1 + use crate::school_test::grade::EntityClient;
  |
help: if you import `EntityClient`, refer to it directly
  |
1 - use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
1 + use sea_orm :: { DatabaseConnection , DatabaseTransaction , TransactionTrait } ; use caustics :: { EntityRegistry , EntityFetcher } ; # [allow (dead_code)] pub struct CausticsClient { db : std :: sync :: Arc < DatabaseConnection > , } # [allow (dead_code)] pub struct TransactionCausticsClient { tx : std :: sync :: Arc < DatabaseTransaction > , } pub struct TransactionBuilder { db : std :: sync :: Arc < DatabaseConnection > , } pub struct CompositeEntityRegistry ; impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { match entity_name { "student" => Some (& student :: EntityFetcherImpl) , "teacher" => Some (& teacher :: EntityFetcherImpl) , "department" => Some (& department :: EntityFetcherImpl) , "course" => Some (& course :: EntityFetcherImpl) , "enrollment" => Some (& enrollment :: EntityFetcherImpl) , "grade" => Some (& grade :: EntityFetcherImpl) , "semester" => Some (& semester :: EntityFetcherImpl) , _ => None , } } } impl < C : sea_orm :: ConnectionTrait > EntityRegistry < C > for & 'static CompositeEntityRegistry { fn get_fetcher (& self , entity_name : & str) -> Option < & dyn EntityFetcher < C >> { (* * self) . get_fetcher (entity_name) } } static REGISTRY : CompositeEntityRegistry = CompositeEntityRegistry ; pub fn get_registry () -> & 'static CompositeEntityRegistry { & REGISTRY } # [allow (dead_code)] impl CausticsClient { pub fn new (db : DatabaseConnection) -> Self { Self { db : std :: sync :: Arc :: new (db) } } pub fn db (& self) -> std :: sync :: Arc < DatabaseConnection > { self . db . clone () } pub fn _transaction (& self) -> TransactionBuilder { TransactionBuilder { db : self . db . clone () , } } pub async fn _batch < 'a , Entity , ActiveModel , ModelWithRelations , T , Container > (& self , queries : Container ,) -> Result < Container :: ReturnType , sea_orm :: DbErr > where Entity : sea_orm :: EntityTrait , ActiveModel : sea_orm :: ActiveModelTrait < Entity = Entity > + sea_orm :: ActiveModelBehavior + Send + 'static , ModelWithRelations : caustics :: FromModel << Entity as sea_orm :: EntityTrait > :: Model > , T : caustics :: MergeInto < ActiveModel > , < Entity as sea_orm :: EntityTrait > :: Model : sea_orm :: IntoActiveModel < ActiveModel > , Container : caustics :: BatchContainer < 'a , sea_orm :: DatabaseConnection , Entity , ActiveModel , ModelWithRelations , T > , { let txn = self . db . begin () . await ? ; let batch_queries = Container :: into_queries (queries) ; let mut results = Vec :: with_capacity (batch_queries . len ()) ; for query in batch_queries { let res = match query { caustics :: BatchQuery :: Insert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Insert (result) } caustics :: BatchQuery :: Update (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Update (result) } caustics :: BatchQuery :: Delete (q) => { q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Delete (()) } caustics :: BatchQuery :: Upsert (q) => { let result = q . exec_in_txn (& txn) . await ? ; caustics :: BatchResult :: Upsert (result) } } ; results . push (res) ; } txn . commit () . await ? ; Ok (Container :: from_results (results)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . db) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . db) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self . db) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseConnection > { grade :: EntityClient :: new (& * self . db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self . db) } } # [allow (dead_code)] impl TransactionCausticsClient { pub fn new (tx : std :: sync :: Arc < DatabaseTransaction >) -> Self { Self { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self . tx) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * self . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . tx) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * self . tx) } pub fn grade (& self) -> grade :: EntityClient < '_ , DatabaseTransaction > { grade :: EntityClient :: new (& * self . tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { EntityClient :: new (& * self . tx) } } impl TransactionBuilder { pub async fn run < F , Fut , T > (& self , f : F) -> Result < T , sea_orm :: DbErr > where F : FnOnce (TransactionCausticsClient) -> Fut , Fut : std :: future :: Future < Output = Result < T , sea_orm :: DbErr >> , { let tx = self . db . begin () . await ? ; let tx_arc = std :: sync :: Arc :: new (tx) ; let tx_client = TransactionCausticsClient :: new (tx_arc . clone ()) ; let result = f (tx_client) . await ; let tx = std :: sync :: Arc :: try_unwrap (tx_arc) . expect ("Transaction Arc should be unique") ; match result { Ok (val) => { tx . commit () . await ? ; Ok (val) } Err (e) => { tx . rollback () . await ? ; Err (e) } } } }
  |

error[E0433]: failed to resolve: could not find `student` in `super`
   --> caustics/tests/school_test.rs:360:54
    |
360 |     #[derive(Caustics, Copy, Clone, Debug, EnumIter, DeriveRelation)]
    |                                                      ^^^^^^^^^^^^^^ could not find `student` in `super`
    |
    = note: this error originates in the derive macro `DeriveRelation` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing one of these items
    |
334 +     use sea_orm_migration::seaql_migrations::Column;
    |
334 +     use sqlx::Column;
    |

error[E0433]: failed to resolve: could not find `course` in `super`
   --> caustics/tests/school_test.rs:360:54
    |
360 |     #[derive(Caustics, Copy, Clone, Debug, EnumIter, DeriveRelation)]
    |                                                      ^^^^^^^^^^^^^^ could not find `course` in `super`
    |
    = note: this error originates in the derive macro `DeriveRelation` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing one of these items
    |
334 +     use sea_orm_migration::seaql_migrations::Column;
    |
334 +     use sqlx::Column;
    |

error[E0433]: failed to resolve: could not find `teacher` in `super`
   --> caustics/tests/school_test.rs:360:54
    |
360 |     #[derive(Caustics, Copy, Clone, Debug, EnumIter, DeriveRelation)]
    |                                                      ^^^^^^^^^^^^^^ could not find `teacher` in `super`
    |
    = note: this error originates in the derive macro `DeriveRelation` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing one of these items
    |
334 +     use sea_orm_migration::seaql_migrations::Column;
    |
334 +     use sqlx::Column;
    |

error[E0433]: failed to resolve: could not find `student` in `super`
   --> caustics/tests/school_test.rs:332:1
    |
332 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `student` in `super`
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing this struct
    |
334 +     use sea_orm_migration::seaql_migrations::Entity;
    |

error[E0433]: failed to resolve: could not find `course` in `super`
   --> caustics/tests/school_test.rs:332:1
    |
332 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `course` in `super`
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing this struct
    |
334 +     use sea_orm_migration::seaql_migrations::Entity;
    |

error[E0433]: failed to resolve: could not find `teacher` in `super`
   --> caustics/tests/school_test.rs:332:1
    |
332 | #[caustics(namespace = "school")]
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ could not find `teacher` in `super`
    |
    = note: this error originates in the attribute macro `caustics` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider importing this struct
    |
334 +     use sea_orm_migration::seaql_migrations::Entity;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
   --> caustics/tests/school_test.rs:865:19
    |
865 |             .with(course::teacher::fetch())
    |                   ^^^^^^ use of unresolved module or unlinked crate `course`
    |
help: there is a crate or module with a similar name
    |
865 -             .with(course::teacher::fetch())
865 +             .with(core::teacher::fetch())
    |
help: consider importing this module
    |
763 +     use crate::school_test::grade::teacher;
    |
help: if you import `teacher`, refer to it directly
    |
865 -             .with(course::teacher::fetch())
865 +             .with(teacher::fetch())
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
   --> caustics/tests/school_test.rs:779:13
    |
779 |             student::Create {
    |             ^^^^^^^ use of unresolved module or unlinked crate `student`
    |
    = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:5199
  |
1 | .... tx) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseTransaction > { semester :: EntityClient :: new (& * self ...
  |                                        ^^^^^^^^ use of unresolved module or unlinked crate `semester`
  |
  = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4936
  |
1 | ...) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseTransaction > { enrollment :: EntityClient :: new (& * sel...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
  |
  = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4804
  |
1 | ...elf . tx) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseTransaction > { course :: EntityClient :: new (& * self . ...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `course`
  |
  = help: if you wanted to use a crate named `course`, use `cargo add course` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4668
  |
1 | ...) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseTransaction > { department :: EntityClient :: new (& * sel...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
  |
  = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4534
  |
1 | ...f . tx) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseTransaction > { teacher :: EntityClient :: new (& * self ....
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `teacher`
  |
  = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3339
  |
1 | ...sults)) } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseConnection > { student :: EntityClient :: new (& * self . ...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `student`
  |
  = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `teacher`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3469
  |
1 | ...f . db) } pub fn teacher (& self) -> teacher :: EntityClient < '_ , DatabaseConnection > { teacher :: EntityClient :: new (& * self . ...
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `teacher`
  |
  = help: if you wanted to use a crate named `teacher`, use `cargo add teacher` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `department`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3602
  |
1 | ...) } pub fn department (& self) -> department :: EntityClient < '_ , DatabaseConnection > { department :: EntityClient :: new (& * self...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `department`
  |
  = help: if you wanted to use a crate named `department`, use `cargo add department` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `course`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3737
  |
1 | ...elf . db) } pub fn course (& self) -> course :: EntityClient < '_ , DatabaseConnection > { course :: EntityClient :: new (& * self . d...
  |                                          ^^^^^^ use of unresolved module or unlinked crate `course`
  |
  = help: if you wanted to use a crate named `course`, use `cargo add course` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `enrollment`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:3868
  |
1 | ...) } pub fn enrollment (& self) -> enrollment :: EntityClient < '_ , DatabaseConnection > { enrollment :: EntityClient :: new (& * self...
  |                                      ^^^^^^^^^^ use of unresolved module or unlinked crate `enrollment`
  |
  = help: if you wanted to use a crate named `enrollment`, use `cargo add enrollment` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `semester`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4129
  |
1 | .... db) } pub fn semester (& self) -> semester :: EntityClient < '_ , DatabaseConnection > { semester :: EntityClient :: new (& * self ....
  |                                        ^^^^^^^^ use of unresolved module or unlinked crate `semester`
  |
  = help: if you wanted to use a crate named `semester`, use `cargo add semester` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `student`
 --> /home/adriano/Sviluppo/caustics/target/debug/build/caustics-006526615d8ba77f/out/caustics_client_school_test.rs:1:4403
  |
1 | ... { tx } } pub fn student (& self) -> student :: EntityClient < '_ , DatabaseTransaction > { student :: EntityClient :: new (& * self ....
  |                                         ^^^^^^^ use of unresolved module or unlinked crate `student`
  |
  = help: if you wanted to use a crate named `student`, use `cargo add student` to add it to your `Cargo.toml`

error: could not compile `caustics` (test "school_test") due to 132 previous errors
error: could not compile `caustics` (test "mod") due to 230 previous errors
